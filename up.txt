# File: ./todo.rb
require 'rubygems'
require 'bundler/setup'
require 'fileutils'
require_relative 'lib/session'

require_relative 'lib/commands'
require_relative 'lib/commands/add'
require_relative 'lib/commands/cursor_set'
require_relative 'lib/commands/cursor_to_start'
require_relative 'lib/commands/display_edit'
require_relative 'lib/commands/down'
require_relative 'lib/commands/edit'
require_relative 'lib/commands/edit_insert'
require_relative 'lib/commands/edit_replace'
require_relative 'lib/commands/find'
require_relative 'lib/commands/global_find'
require_relative 'lib/commands/grab_toggle'
require_relative 'lib/commands/help'
require_relative 'lib/commands/insert_blank'
require_relative 'lib/commands/iterative_find'
require_relative 'lib/commands/month_summaries'
require_relative 'lib/commands/move_task_to_other'
require_relative 'lib/commands/save_to_yesterday'
require_relative 'lib/commands/quit'
require_relative 'lib/commands/up'

require_relative 'lib/appio'
require_relative 'lib/backgroundio'
require_relative 'lib/headlessio.rb'
require_relative 'lib/todoupdater'


class ToDo
  @@commands = [Add.new,
                CursorSet.new,
                CursorToStart.new,
                DisplayEdit.new,
                Down.new,
                Edit.new,
                EditInsert.new,
                EditReplace.new,
                Find.new,
                GlobalFind.new,
                GrabToggle.new,
                Help.new,
                InsertBlank.new,
                IterativeFind.new,
                MonthSummaries.new,
                MoveTaskToOther.new,
                ToDoMoveToRandomPositionOnOtherList.new,
                ToDoPageDown.new,
                ToDoPageUp.new,
                ToDoPrintArchive.new,
                ToDoPush.new,
                Quit.new,
                ToDoReTag.new,
                ToDoRemove.new,
                ToDoSave.new,
                ToDoSaveActions.new,
                ToDoSaveNoRemove.new,
                SaveToYesterday.new,
                ToDoShowCommandFrequencices.new,
                ToDoShowUpdates.new,
                ToDoSurface.new,
                ToDoSwitchLists.new,
                ToDoTagTallies.new,
                ToDoTodayTargetFor.new,
                ToDoToday.new,
                ToDoTrend.new,
                ToDoTrendChart.new,
                Up.new,
                ToDoZapToPosition.new,
                ToDoZapToTop.new]


  def self.registered_commands
    @@commands
  end

  def initialize foreground_io, background_io
    @foreground_io = foreground_io
    @background_io = background_io
    ToDoUpdater.new(@foreground_io).run
    @session = Session.from_ios(@foreground_io, @background_io)
    @session.render
  end

  def run
    while true
      on_line(@session.get_line, @session)
      @session.render
    end
  end

  def on_line line, session
    result = CommandResult.new
    @@commands.each {|c| c.run(line, session, result) }
    @session.log_command(result.matches.first.name) if result.match_count > 0
    process_result(result, line)
  end

  def process_result result, line
    return unless result.match_count == 0 && line.split.count > 0
    @session.message_and_wait("Unrecognized command: " + line + $/)
  end

end


def run
  return puts "Another instance of todo is already running." if File.exist?(LOCK_FILE)

  FileUtils.touch(LOCK_FILE)
  ios = ARGV.empty? ? [AppIo, BackgroundIo] : [HeadlessIo, HeadlessIo]
  ToDo.new(*ios.map(&:new)).run
ensure
  FileUtils.rm(LOCK_FILE) if File.exist?(LOCK_FILE)
end

run

# File: ./spec/spec_helper.rb
require 'rubygems'
require 'bundler/setup'

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'simplecov'

SimpleCov.start do
  add_filter '/spec/' # Exclude spec files from coverage
  add_filter '/lib/appio.rb'
end

Dir[File.expand_path('../lib/**/*.rb', __FILE__)].each { |f| require f }

RSpec.configure do |config|
  # Additional RSpec configuration can go here
end

# File: ./spec/session_spec.rb
require 'spec_helper'
require 'session'
require 'commands'
require 'fakeappio'


describe Session do

  before(:each) do
    @io = FakeAppIo.new
    @session = Session.from_ios(@io, @io)
  end

  it 'updates the existing command log' do
    @io.log_content = "c,12\nz,10"
    @session = Session.from_ios(@io, @io)
    @session.log_command("z")
    expect(@io.log_content).to eq("c,12\nz,11")
  end

  it 'adds to existing command log' do
    @io.log_content = "c,12\nz,10\n"
    @session = Session.from_ios(@io, @io)
    @session.log_command("t")
    expect(@io.log_content).to eq("c,12\nz,10\nt,1")
  end

  it 'adds to an empty command log' do
    @io.log_content = ""
    @session = Session.from_ios(@io, @io)
    @session.log_command("t")
    expect(@io.log_content).to eq("t,1")
  end

end


describe 'Session#surface' do
  before(:each) do
    @foreground_io = FakeAppIo.new
    @background_io = FakeAppIo.new
  end

  it 'moves the specified number of random tasks from background to foreground' do
    @background_io.tasks_content = "Task 1\nTask 2\nTask 3"
    @session = Session.from_ios(@foreground_io, @background_io)

    @session.surface(2)
    @session.save

    expect(@foreground_io.tasks_content.split("\n").size).to eq(2)
    expect(@background_io.tasks_content.split("\n").size).to eq(1)
  end

  it 'moves all tasks from background to foreground if count exceeds background size' do
    @background_io.tasks_content = "Task 1\nTask 2"
    @session = Session.from_ios(@foreground_io, @background_io)
    @session.surface(5)
    @session.save

    expect(@foreground_io.tasks_content.split("\n").size).to eq(2)
    expect(@background_io.tasks_content).to eq("")
  end
end

# File: ./spec/taskselection_spec.rb
require 'spec_helper'
require 'taskselection'


describe TaskSelection do
  describe '#percent_of' do
    let(:descs) do
      [
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 1)), 'L'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 2)), 'R'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 3)), 'L'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 4)), 'W'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 5)), 'R')
      ]
    end

    let(:task_selection) { TaskSelection.new(descs) }

    it 'calculates the percentage of tasks in the selection compared to another selection' do
      other_descs = [
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 1)), 'L'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 2)), 'R'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 3)), 'L'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 4)), 'W'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 5)), 'R'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 6)), 'W'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 7)), 'L'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 8)), 'R'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 9)), 'W'),
        TaskDesc.new(Day.new(DateTime.new(2023, 1, 10)), 'L')
      ]
      other_selection = TaskSelection.new(other_descs)

      expect(task_selection.percent_of(other_selection)).to eq(50)
    end

    it 'returns 0 if the other selection is empty' do
      other_selection = TaskSelection.new([])

      expect(task_selection.percent_of(other_selection)).to eq(0)
    end

    it 'returns 100 if the other selection is the same as the current selection' do
      expect(task_selection.percent_of(task_selection)).to eq(100)
    end

    it 'returns 0 if the current selection is empty' do
      empty_selection = TaskSelection.new([])
      other_selection = TaskSelection.new(descs)

      expect(empty_selection.percent_of(other_selection)).to eq(0)
    end
  end
end

# File: ./spec/fakeappio.rb


class FakeAppIo

  attr_accessor :archive_content, :console_output_content
  attr_accessor :console_input_content, :tasks_content
  attr_accessor :update_content, :today_content
  attr_accessor :log_content

  def initialize
    @archive_content = @tasks_content = ""
    @console_output_content = ""
    @log_content = ""
    @update_content = []
  end

  def read_archive
    @archive_content
  end

  def write_archive archive_entries
    @archive_content = archive_entries.join
  end

  def read_log
    @log_content
  end

  def write_log text
    @log_content = text
  end

  def append_to_log line
  end

  def append_to_archive text
    @archive_content = @archive_content + text
  end

  def append_to_junk text
  end

  def read_tasks
    @tasks_content
  end

  def write_tasks tasks
    @tasks_content = tasks.join
  end

  def read_updates
    @update_content
  end

  def write_updates updates
    @update_content = updates
  end

  def append_to_console text
    @console_output_content = @console_output_content + text
  end

  def get_from_console
    text = @console_input_content
    @console_input_content = ""
    text
  end

  def clear_console
  end

  def today
    @today_content
  end

  def renderer
    NullRenderer.new
  end

end

# File: ./spec/tasklist_spec.rb
require 'spec_helper'
require 'tasklist'
require 'fakeappio'

require 'commands/add'
require 'commands/Help'


empty_archive_expected = "

             Win        R7K       Life      Total   Adjusted

Jan            0          0          0          0          0
Feb            0          0          0          0          0
Mar            0          0          0          0          0
Apr            0          0          0          0          0
May            0          0          0          0          0
Jun            0          0          0          0          0
Jul            0          0          0          0          0
Aug            0          0          0          0          0
Sep            0          0          0          0          0
Oct            0          0          0          0          0
Nov            0          0          0          0          0
Dec            0          0          0          0          0

               0          0          0          0          0



"

TEST_COLUMNS = [["Win",   ->(tasks) { tasks.W.count } ],
                ["R7K",   ->(tasks) { tasks.R.count } ],
                ["Life",  ->(tasks) { tasks.L.count } ],
                ["Total", ->(tasks) { tasks.count } ],
                ["Adjusted", ->(tasks) { tasks.adjusted_count } ]]


class TestingHelp < Help
  attr_accessor :descs

  def command_descs
    @descs
  end
end

describe TaskList do
  let(:io) { FakeAppIo.new }
  let(:task_list) { TaskList.new(io) }

  describe '#todo_show_updates' do
    let(:io) { FakeAppIo.new }
    let(:task_list) { TaskList.new(io) }

    context 'when there are updates' do
      before do
        io.update_content = "2023-06-01 Update 1\n2023-06-02 Update 2\n"
      end

      it 'clears the console' do
        expect(io).to receive(:clear_console)
        task_list.todo_show_updates
      end

      it 'appends the updates to the console' do
        task_list.todo_show_updates
        expect(io.console_output_content).to eq("2023-06-01 Update 1\n2023-06-02 Update 2\n")
      end

      it 'returns to the prompt after displaying the updates' do
        expect(io).to receive(:get_from_console)
        task_list.todo_show_updates
      end
    end

    context 'when there are no updates' do
      before do
        io.update_content = ""
      end

      it 'clears the console' do
        expect(io).to receive(:clear_console)
        task_list.todo_show_updates
      end

      it 'does not append anything to the console' do
        task_list.todo_show_updates
        expect(io.console_output_content).to eq("")
      end

      it 'returns to the prompt' do
        expect(io).to receive(:get_from_console)
        task_list.todo_show_updates
      end
    end
   end

   describe '#todo_save' do
     context 'when there are tasks in the list' do
       before do
        io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"
        io.today_content = Day.new(DateTime.new(2023, 6, 1))
        task_list.cursor_set(1)
      end

      it 'appends the task at the cursor to the archive' do
        task_list.todo_save

        expect(io.archive_content).to eq("2023-06-01 L: task 2\n")
      end

      it 'removes the task at the cursor from the tasks' do
        task_list.todo_save

        expect(task_list.window).to eq([[0, " ", "L: task 1\n"], [1, "-", "L: task 3\n"]])
      end

      it 'updates the cursor position to the next task' do
        task_list.todo_save

        expect(task_list.window).to eq([[0, " ", "L: task 1\n"], [1, "-", "L: task 3\n"]])
      end

      it 'updates the cursor position to the previous task when at the last task' do
        task_list.cursor_set(2)
        task_list.todo_save

        expect(task_list.window).to eq([[0, " ", "L: task 1\n"], [1, "-", "L: task 2\n"]])
      end
    end

    context 'when the list is empty' do
      before do
        io.tasks_content = ""
      end

      it 'does not append anything to the archive' do
        task_list.todo_save

        expect(io.archive_content).to eq("")
      end

      it 'does not modify the tasks' do
        task_list.todo_save

        expect(io.tasks_content).to eq("")
      end
    end

    context 'when the task at the cursor is empty' do
      before do
        io.tasks_content = "L: task 1\n\nL: task 3\n"
        task_list.cursor_set(1)
      end

      it 'does not append anything to the archive' do
        task_list.todo_save

        expect(io.archive_content).to eq("")
      end

      it 'does not remove the empty task from the tasks' do
        task_list.todo_save

        expect(io.tasks_content).to eq("L: task 1\n\nL: task 3\n")
      end
    end
  end

    describe '#todo_save_no_remove' do
    context 'when there are tasks in the list' do
      before do
        io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"
        io.today_content = Day.new(DateTime.new(2023, 6, 1))
        task_list.cursor_set(1)
      end

      it 'appends the task at the cursor to the archive' do
        task_list.todo_save_no_remove

        expect(io.archive_content).to eq("2023-06-01 L: task 2\n")
      end

      it 'does not remove the task at the cursor from the tasks' do
        task_list.todo_save_no_remove

        expect(io.tasks_content).to eq("L: task 1\nL: task 2\nL: task 3\n")
      end

      it 'does not modify the cursor position' do
        task_list.todo_save_no_remove

        expect(task_list.window).to eq([[0, " ", "L: task 1\n"], [1, "-", "L: task 2\n"], [2, " ", "L: task 3\n"]])
      end
    end

    context 'when the list is empty' do
      before do
        io.tasks_content = ""
      end

      it 'does not append anything to the archive' do
        task_list.todo_save_no_remove

        expect(io.archive_content).to eq("")
      end

      it 'does not modify the tasks' do
        task_list.todo_save_no_remove

        expect(io.tasks_content).to eq("")
      end
    end

    context 'when the task at the cursor is empty' do
      before do
        io.tasks_content = "L: task 1\n\nL: task 3\n"
        task_list.cursor_set(1)
      end

      it 'does not append anything to the archive' do
        task_list.todo_save_no_remove

        expect(io.archive_content).to eq("")
      end

      it 'does not modify the tasks' do
        task_list.todo_save_no_remove

        expect(io.tasks_content).to eq("L: task 1\n\nL: task 3\n")
      end
    end
  end


  describe '#up' do
    it 'moves the cursor up by one position' do
      # io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"
      task_list.add("L: T 3");
      task_list.add("L: T 2");
      task_list.add("L: T 1");

      task_list.cursor_set(2)

      task_list.up

      expect(task_list.window).to eq([[0, " ", "L: T 1\n"],
                                      [1, "-", "L: T 2\n"],
                                      [2, " ", "L: T 3\n"]])

    end

    it 'does not move the cursor if it is already at the first task' do
      io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"
      task_list.cursor_set(0)

      task_list.up

      expect(task_list.window).to eq([[0, "-", "L: task 1\n"], [1, " ", "L: task 2\n"], [2, " ", "L: task 3\n"]])
    end

    it 'moves the task above the cursor down when in grab mode' do
      io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"

      task_list.cursor_set(1)
      task_list.todo_grab_toggle

      task_list.up

      expect(task_list.window[0]).to eq([0, "*",  "L: task 2\n"])
      expect(task_list.window[1]).to eq([1, " ",  "L: task 1\n"])
    end

    it 'does not move the task above the cursor down when not in grab mode' do
      io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"

      task_list.cursor_set(1)

      task_list.up

      expect(task_list.window[0]).to eq([0, "-",  "L: task 1\n"])
      expect(task_list.window[1]).to eq([1, " ",  "L: task 2\n"])
    end
  end

  it 'returns task at cursor when not empty' do
    io.tasks_content = "L: task AA\nL: task BB\n"
    expect(task_list.task_at_cursor).to eq("L: task AA")
  end

  it 'returns empty string for task at cursor when empty' do
    expect(task_list.task_at_cursor).to eq("")
  end

  it 'finds simple text' do
    io.tasks_content = "L: task AA\nL: task BB\n"
    expect(task_list.find("AA")).to eq([" 0 L: task AA\n"])
  end

  it 'ignores case when it finds' do
    io.tasks_content = "L: task A\nL: task B\n"
    expect(task_list.find("b")).to eq([" 1 L: task B\n"])
  end

  it 'produces a summary for an empty archive' do
    io.today_content = Day.from_text("2020-01-01")
    MonthsReport.new(io, nil, TEST_COLUMNS).run
    # task_list.todo_month_summaries TEST_COLUMNS

    expect(io.console_output_content).to eq(empty_archive_expected)
  end

  it 'shows archive entries of today' do
    io.archive_content = "2020-01-11 R: Thing X\n2020-01-12 R: Thing Y\n"
    io.today_content = Day.from_text("2020-01-12")
    task_list.todo_today 0
    expect(io.console_output_content).to eq("\n2020-01-12 R: Thing Y\n\n1\n\n")
  end

  it 'shows trend' do
    io.archive_content = "2020-01-11 R: Thing X\n2020-01-12 R: Thing Y\n2020-01-12 L: Another thing\n"
    task_list.todo_trend
    expect(io.console_output_content).to eq("  1  2020-01-11\n  2  2020-01-12\n\n")
  end

  it 'adds a task on an empty todo list' do
    io.tasks_content = ""
    task_list.add("this is a test")
    expect(task_list.window).to eq([[0, "-", "this is a test\n"]])
  end

  it 'adds a task on an non-empty todo list' do
    io.tasks_content = "L: task A\n"
    task_list.add("L: this is a test")

    expect(task_list.window).to eq([[0, "-", "L: this is a test\n"],[1, " ", "L: task A\n"]])
  end

  it 'moves the cursor on an add' do
    io.tasks_content = 50.times.map { "L: task\n" }.join
    task_list.todo_page_down
    task_list.add("L: new task")

    expect(task_list.window[0]).to eq([0, "-", "L: new task\n"])
  end

  it 'does not write to archive when saving an empty todo list' do
    io.tasks_content = ""
    task_list.todo_save

    expect(task_list.window).to eq([])
  end

  it 'does not write to archive when save_no_remove on an empty todo list' do
    io.tasks_content = ""
    task_list.todo_save_no_remove

    expect(task_list.window).to eq([])
  end

  it 'pushes task at cursor to next day' do
    io.tasks_content = "L: task A\n"
    io.update_content = ""
    io.today_content = Day.from_text("2022-12-21")
    task_list.todo_push "1"

    expect(io.update_content.first).to eq("2022-12-22 L: task A\n")
    expect(task_list.window).to eq([])
  end

  it 'noops push on no tasks' do
    io.update_content = []
    io.today_content = Day.from_text("2022-12-21")
    task_list.todo_push "1"

    expect(io.update_content).to eq([])
    expect(task_list.window).to eq([])
  end

  it 'preserves a tag on editing' do
    io.tasks_content = "L: task\n"
    task_list.edit "edited task"

    expect(task_list.window).to eq([[0, "-", "L: edited task\n"]])
  end

  it 'can return 1 tag tally' do
    io.tasks_content = "L: task\n"
    expect(task_list.tag_tallies).to eq ([["L:", 1]])
  end

  it 'can return 2 tag tallies' do
    io.tasks_content = "L: task\nR: task\nR: task\n"
    expect(task_list.tag_tallies).to eq ([["L:",1],["R:", 2]])
  end

  it 'can return 2 tag tallies' do
    io.tasks_content = "L: task\nR: task\nutaski\nR: task\nutask\n"
    expect(task_list.untagged_tally).to eq (2)
  end


  describe '#todo_today_target_for' do
    before do
      allow(io).to receive(:append_to_console)
      allow(io).to receive(:get_from_console)
    end

    context 'when the monthly goal has been met' do
      it 'displays a message indicating the goal has been met' do
        io.today_content = Day.from_text("2023-06-15")
        io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n2023-06-03 R: Task 3\n"

        expect(io).to receive(:append_to_console).with("\n\n    Goal met\n\n")
        task_list.todo_today_target_for(3)
      end
    end

    context 'when it is the last day of the month' do
      it 'displays the number of tasks needed to meet the monthly goal' do
        io.today_content = Day.from_text("2023-06-30")
        io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n"

        expect(io).to receive(:append_to_console).with("\n\n    Do 3 to meet monthly goal of 5\n\n")
        task_list.todo_today_target_for(5)
      end
    end

    context 'when additional tasks are needed today' do
      xit 'displays the number of additional tasks needed today' do
        io.today_content = Day.from_text("2023-06-15")
        io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n2023-06-15 R: Task 3\n"

        expect(io).to receive(:append_to_console).with("\n\n    Do 2 to meet daily goal of 3\n\n")
        task_list.todo_today_target_for(30)
      end
    end

    context 'when no additional tasks are needed today' do
      it 'displays a message indicating the goal has been met' do
        io.today_content = Day.from_text("2023-06-15")
        io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n2023-06-15 R: Task 3\n2023-06-15 R: Task 4\n2023-06-15 R: Task 5\n"

        expect(io).to receive(:append_to_console).with("\n\n    Goal met\n\n")
        task_list.todo_today_target_for(30)
      end
    end

    it 'displays the average tasks completed so far' do
      io.today_content = Day.from_text("2023-06-15")
      io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n2023-06-15 R: Task 3\n"

      expect(io).to receive(:append_to_console).with(/\n\n   Average so far:   0.\d+/)
      task_list.todo_today_target_for(30)
    end

    it 'displays the average tasks needed per day to meet the goal' do
      io.today_content = Day.from_text("2023-06-15")
      io.archive_content = "2023-06-01 R: Task 1\n2023-06-02 R: Task 2\n2023-06-15 R: Task 3\n"

      expect(io).to receive(:append_to_console).with(/\n   Average needed:   1.\d+/)
      task_list.todo_today_target_for(30)
    end
  end



end




# File: ./spec/consolerenderer_spec.rb

require 'spec_helper'
require 'consolerenderer'
require 'fakeappio'

describe ConsoleRenderer do
  let(:io) { FakeAppIo.new }
  let(:renderer) { ConsoleRenderer.new }
  let(:tasklist) { double('TaskList') }

  before do
    allow(tasklist).to receive(:io).and_return(io)
    allow(io).to receive(:clear_console)
    allow(io).to receive(:append_to_console)
  end

  describe '#render' do
    it 'clears the console before rendering' do
      allow(tasklist).to receive(:description).and_return("")
      allow(tasklist).to receive(:window).and_return([])

      expect(io).to receive(:clear_console)
      renderer.render(tasklist)
    end

    it 'renders the task list description' do
      description = "Task List\n\n"
      allow(tasklist).to receive(:description).and_return(description)
      allow(tasklist).to receive(:window).and_return([])

      expect(io).to receive(:append_to_console).with(description)
      renderer.render(tasklist)
    end

    it 'renders tasks with proper formatting' do
      window = [
        [0, "-", "L: task 1\n"],
        [1, " ", "L: task 2\n"]
      ]
      allow(tasklist).to receive(:description).and_return("")
      allow(tasklist).to receive(:window).and_return(window)

      expected_output = " 0 \e[41m- L: task 1\n\e[0m" + 
                       " 1   L: task 2\n" +
                       "\n"

      expect(io).to receive(:append_to_console).with("")
      expect(io).to receive(:append_to_console).with(expected_output)
      
      renderer.render(tasklist)
    end

    it 'renders tasks with cursor highlighting' do
      window = [
        [0, "-", "L: task 1\n"],
        [1, "*", "L: task 2\n"],
        [2, " ", "L: task 3\n"]
      ]
      allow(tasklist).to receive(:description).and_return("")
      allow(tasklist).to receive(:window).and_return(window)

      expected_output = " 0 \e[41m- L: task 1\n\e[0m" +
                        " 1 \e[41m* L: task 2\n\e[0m" +
                        " 2   L: task 3\n" +
                        "\n"

      expect(io).to receive(:append_to_console).with("")
      expect(io).to receive(:append_to_console).with(expected_output)
      
      renderer.render(tasklist)
    end

    it 'handles empty task lists' do
      allow(tasklist).to receive(:description).and_return("")
      allow(tasklist).to receive(:window).and_return([])

      expected_output = "\n"

      expect(io).to receive(:append_to_console).with("")
      expect(io).to receive(:append_to_console).with(expected_output)
      
      renderer.render(tasklist)
    end

    it 'handles tasks with varying line numbers' do
      window = [
        [9, "-", "L: task 9\n"],
        [10, " ", "L: task 10\n"]
      ]
      allow(tasklist).to receive(:description).and_return("")
      allow(tasklist).to receive(:window).and_return(window)

      expected_output = " 9 \e[41m- L: task 9\n\e[0m"  +
                        "10   L: task 10\n" +
                        "\n"

      expect(io).to receive(:append_to_console).with("")
      expect(io).to receive(:append_to_console).with(expected_output)
      
      renderer.render(tasklist)
    end
  end

end
# File: ./spec/taskdesc_spec.rb
require 'spec_helper'
require 'day'
require 'taskdesc'

describe TaskDesc do
  describe '.from_line' do
    it 'creates a TaskDesc object from a valid line' do
      line = "2023-06-15 R:"
      task_desc = TaskDesc.from_line(line)

      expect(task_desc).to be_a(TaskDesc)
      expect(task_desc.date).to eq(Day.from_text("2023-06-15"))
      expect(task_desc.task_type).to eq("R")
    end

    it 'handles different task types correctly' do
      lines = [
        "2023-06-15 L: Life task",
        "2023-06-16 W: Work task",
        "2023-06-17 R: Regular task"
      ]

      task_descs = lines.map { |line| TaskDesc.from_line(line) }

      expect(task_descs[0].task_type).to eq("L")
      expect(task_descs[1].task_type).to eq("W")
      expect(task_descs[2].task_type).to eq("R")
    end

    it 'creates a Day object with the correct date' do
      line = "2023-12-31 R: New Year's Eve task"
      task_desc = TaskDesc.from_line(line)

      expect(task_desc.date).to be_a(Day)
      expect(task_desc.date.year).to eq("2023")
      expect(task_desc.date.month).to eq("Dec")
      expect(task_desc.date.day).to eq("31")
    end

    it 'ignores the task description part' do
      line = "2023-06-15 R: This is a long task description with multiple words"
      task_desc = TaskDesc.from_line(line)

      expect(task_desc.date).to eq(Day.from_text("2023-06-15"))
      expect(task_desc.task_type).to eq("R")
      # The TaskDesc object doesn't store the full description
    end

  end
end

# File: ./spec/commands_spec.rb
require 'spec_helper'
require 'session'
require 'commands'
require 'fakeappio'
require 'testrenderer'

RENDER_PAD = "\n\n"


describe ToDoMoveToRandomPositionOnOtherList do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  describe '#run' do
    it 'moves the task at the cursor from the foreground list to a random position on the background list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"
      session.list.cursor_set(1)

      expect_any_instance_of(Session).to receive(:move_task_to_random_position_on_other_list)

      ToDoMoveToRandomPositionOnOtherList.new.run('_', session)
    end

    it 'moves the task at the cursor from the background list to a random position on the foreground list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"
      session.switch_lists
      session.list.cursor_set(1)

      expect_any_instance_of(Session).to receive(:move_task_to_random_position_on_other_list)

      ToDoMoveToRandomPositionOnOtherList.new.run('_', session)
    end

    it 'does not modify the lists if the foreground list is empty' do
      f_io.tasks_content = ""
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      expect_any_instance_of(Session).not_to receive(:move_task_to_random_position_on_other_list)

      ToDoMoveToRandomPositionOnOtherList.new.run('_', session)
    end

    it 'does not modify the lists if the background list is empty' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = ""
      session.switch_lists

      expect_any_instance_of(Session).not_to receive(:move_task_to_random_position_on_other_list)

      ToDoMoveToRandomPositionOnOtherList.new.run('_', session)
    end
  end

  describe '#matches?' do
    it 'matches a command with "_"' do
      expect(ToDoMoveToRandomPositionOnOtherList.new.matches?('_')).to be_truthy
    end

    it 'does not match a command other than "_"' do
      expect(ToDoMoveToRandomPositionOnOtherList.new.matches?('x')).to be_falsey
    end
  end
end


describe ToDoTagTallies do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  describe '#run' do
    it 'displays tag tallies and untagged count' do
      f_io.tasks_content = "L: task 1\nR: task 2\nR: task 3\nW: task 4\nL: task 5\ntask 6\ntask 7\n"

      ToDoTagTallies.new.run('tt', session)

      expect(f_io.console_output_content).to include("   L:          2")
      expect(f_io.console_output_content).to include("   R:          2")
      expect(f_io.console_output_content).to include("   W:          1")
      expect(f_io.console_output_content).to include("   Untagged    2")
    end

    it 'returns to the prompt after displaying tag tallies' do
      f_io.tasks_content = "L: task 1\nR: task 2\nR: task 3\nW: task 4\nL: task 5\ntask 6\ntask 7\n"

      expect(f_io).to receive(:get_from_console)

      ToDoTagTallies.new.run('tt', session)
    end

    it 'displays only untagged count when no tags are present' do
      f_io.tasks_content = "task 1\ntask 2\ntask 3\n"

      ToDoTagTallies.new.run('tt', session)

      expect(f_io.console_output_content).not_to include("L:")
      expect(f_io.console_output_content).not_to include("R:")
      expect(f_io.console_output_content).not_to include("W:")
      expect(f_io.console_output_content).to include("   Untagged    3")
    end

    it 'displays tag tallies correctly when only one tag is present' do
      f_io.tasks_content = "L: task 1\nL: task 2\nL: task 3\n"

      ToDoTagTallies.new.run('tt', session)

      expect(f_io.console_output_content).to include("   L:          3")
      expect(f_io.console_output_content).to include("   Untagged    0")
    end

    it 'does not count empty lines as untagged tasks' do
      f_io.tasks_content = "L: task 1\n\nR: task 2\n\n\n"

      ToDoTagTallies.new.run('tt', session)

      expect(f_io.console_output_content).to include("   L:          1")
      expect(f_io.console_output_content).to include("   R:          1")
      expect(f_io.console_output_content).to include("   Untagged    0")
    end
  end

  describe '#matches?' do
    it 'matches a command with "tt"' do
      expect(ToDoTagTallies.new.matches?('tt')).to be_truthy
    end

    it 'does not match a command other than "tt"' do
      expect(ToDoTagTallies.new.matches?('xx')).to be_falsey
    end
  end
end

describe ToDoRemove do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  it 'removes an task' do
    f_io.tasks_content = "L: task AA\nL: task BB\n"
    f_io.console_input_content = "Y"
    ToDoRemove.new.run("r", session)
    expect(f_io.tasks_content).to eq("L: task BB\n")
  end
end


def cursor_char index
  return "-" if index == 0
  " "
end

describe ToDoPageDown do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  it 'shows the first page of tasks' do
    tasks =  50.times.map {|n| "L: task #{n}\n" }
    output  =  50.times.map {|n| [n,cursor_char(n), "L: task #{n}\n"] }
    f_io.tasks_content = tasks.join
    
    expect(o).to eq(output.take(TaskList::PAGE_SIZE))
  end

  it 'shows the second page of tasks' do
    tasks =  50.times.map {|n| "L: task #{n}\n" }
    output  =  50.times.map {|n| [n,cursor_char(n), "L: task #{n}\n"] }
    f_io.tasks_content = tasks.join
    ToDoPageDown.new.run("dd", session)

    expect(o).to eq(output.drop(TaskList::PAGE_SIZE).take(TaskList::PAGE_SIZE))
  end

  it 'is noop when on the last page' do
    tasks =  50.times.map {|n| "L: task #{n}\n" }
    output  =  50.times.map {|n| [n,cursor_char(n),"L: task #{n}\n"] }
    f_io.tasks_content = tasks.join
    ToDoPageDown.new.run("dd", session)
    ToDoPageDown.new.run("dd", session)

    expect(o).to eq(output.drop(TaskList::PAGE_SIZE).take(TaskList::PAGE_SIZE))
  end
end

describe ToDoPageUp do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }


  it 'shows the first page of tasks' do
    tasks =  50.times.map {|n| "L: task #{n}\n" }
    output  =  50.times.map {|n| [n,cursor_char(n),"L: task #{n}\n"] }
    
    f_io.tasks_content = tasks.join
    ToDoPageUp.new.run("uu", session)

    expect(o).to eq(output.take(TaskList::PAGE_SIZE))
  end

  it 'shows the first page of tasks after previously paging down' do
    tasks =  50.times.map {|n| "L: task #{n}\n" }
    output  =  50.times.map {|n| [n,cursor_char(n),"L: task #{n}\n"] }
    f_io.tasks_content = tasks.join
    ToDoPageDown.new.run("dd", session)
    ToDoPageUp.new.run("uu", session)
   
    expect(o).to eq(output.take(TaskList::PAGE_SIZE))
  end     

end

describe ToDoPrintArchive do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  it 'prints the contents of the archive' do
    archive_content = "2023-06-07 L: Task 1\n2023-06-08 R: Task 2\n"
    f_io.archive_content = archive_content

    ToDoPrintArchive.new.run("pa", session)

    expect(f_io.console_output_content).to eq(archive_content)
  end

  it 'prints an empty archive when there are no saved tasks' do
    f_io.archive_content = ""

    ToDoPrintArchive.new.run("pa", session)

    expect(f_io.console_output_content).to eq("")
  end

end


describe ToDoZapToPosition do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) {rendering_of(session) }

  it 'zaps the item at zero to one' do
    f_io.tasks_content = [ "L: first\n", "L: second\n"].join
    output = [[0, "-", "L: second\n"], [1, " ", "L: first\n"]]
    ToDoZapToPosition.new.run("z 1", session)
  
    expect(o).to eq(output)
  end

  it 'saturates when asked to zap outside the range high' do
    f_io.tasks_content = [ "L: first\n", "L: second\n"].join
    ToDoZapToPosition.new.run("z 2", session)
    output = [[0, "-", "L: second\n"], [1, " ", "L: first\n"]]
    
    expect(o).to eq(output)
  end

  it 'saturates when asked to zap outside the range low' do
    f_io.tasks_content = [ "L: first\n", "L: second\n"].join
    output = [[0," ", "L: second\n"], [1, "-", "L: first\n"]]
    CursorSet.new.run("c 1", session)
    ToDoZapToPosition.new.run("z -1", session)
    
    expect(o).to eq(output)
  end

  it 'noops when asked to zap to the same position' do
    f_io.tasks_content = [ "L: first\n", "L: second\n"].join
    output = [[0,"-", "L: first\n"], [1, " ", "L: second\n"]]
    ToDoZapToPosition.new.run("z 0", session)

    expect(o).to eq(output)
  end

  it 'has insertion rather than swap aemantics' do
    f_io.tasks_content = [ "L: first\n", "L: second\n",  "L: third\n"].join
    output =  [[0, "-", "L: second\n"],[1, " ", "L: third\n"], [2, " ", "L: first\n"]]
    ToDoZapToPosition.new.run("z 2", session)

    expect(o).to eq(output)
  end

end

describe ToDoReTag do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'retags an L to an R' do
    f_io.tasks_content = [ "L: first\n", "L: second\n",  "L: third\n"].join
    output = [[0, " ", "L: first\n"],[1, "-", "R: second\n"], [2, " ", "L: third\n"]]

    CursorSet.new.run("c 1", session)
    ToDoReTag.new.run("rt r", session)

    expect(o).to eq(output)
  end

  it'does nothing when regtagging in an empty task list' do
    f_io.tasks_content = ""
    output =  []
    ToDoReTag.new.run("rt r", session)

    expect(o).to eq([])
   end

   it 'adds a tag to a task with no tag' do
     f_io.tasks_content = "L: first\n"
     output =  [[0, "-", "L: first\n"]]

     ToDoReTag.new.run("rt l", session)

    expect(o).to eq(output)
   end

 end


describe ToDoToday do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

   it'shows the tasks for the current day' do
     f_io.archive_content = "2020-01-11 R: Thing X\n2020-01-12 R: Thing Y\n"
     f_io.today_content = Day.from_text("2020-01-12")
     ToDoToday.new.run("t", session)
     expect(f_io.console_output_content).to eq("\n2020-01-12 R: Thing Y\n\n1\n\n")
   end


   it'shows the tasks for the previous day' do
     f_io.archive_content = "2020-01-11 R: Thing X\n2020-01-12 R: Thing Y\n"
     f_io.today_content = Day.from_text("2020-01-12")
     ToDoToday.new.run("t 1", session)
     expect(f_io.console_output_content).to eq("\n2020-01-11 R: Thing X\n\n1\n\n")
   end

end


describe ToDoSwitchLists do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'switches away foreground' do
     f_io.tasks_content = [ 
      "L: first\n", 
      "L: second\n",
      "L: third\n"
    ].join

     output = [
      [0, "-", "L: first\n"],
      [1, " ", "L: second\n"],
      [2, " ", "L: third\n"],
    ]

    expect(o).to eq(output)

    ToDoSwitchLists.new.run("w", session)

    expect(rendering_of(session)).to eq([])
  end

  it 'switches foreground and background' do
     f_io.tasks_content = [ "L: first\n", "L: second\n",  "L: third\n"].join
     b_io.tasks_content = [ "R: first\n", "R: second\n",  "R: third\n"].join

    output_before = [ 
      [0, "-", "L: first\n"],
      [1, " ", "L: second\n"],
      [2, " ", "L: third\n"]
    ]

    output_after  = [ 
      [0, "-", "R: first\n"],
      [1, " ", "R: second\n"],
      [2, " ", "R: third\n"]
    ]

    expect(o).to eq(output_before)

    ToDoSwitchLists.new.run("w", session)

    expect(rendering_of(session)).to eq(output_after)
  end

  it 'switches to the background list and moves the cursor to the specified position' do
    f_io.tasks_content = [ "L: first\n", "L: second\n",  "L: third\n"].join
    b_io.tasks_content = [ "R: first\n", "R: second\n",  "R: third\n"].join

    output_after  = [ 
      [0, " ", "R: first\n"],
      [1, "-", "R: second\n"],
      [2, " ", "R: third\n"]
    ]

    ToDoSwitchLists.new.run("w 1", session)

    expect(o).to eq(output_after)
  end

  it 'does not change the cursor position if no position is specified' do
    f_io.tasks_content = [ "L: first\n", "L: second\n",  "L: third\n"].join
    b_io.tasks_content = [ "R: first\n", "R: second\n",  "R: third\n"].join

    output_after  = [ 
      [0, "-", "R: first\n"],
      [1, " ", "R: second\n"],
      [2, " ", "R: third\n"]
    ]

    ToDoSwitchLists.new.run("w", session)

    output_after  = [ 
      [0, "-", "R: first\n"],
      [1, " ", "R: second\n"],
      [2, " ", "R: third\n"]
    ]

    expect(o).to eq(output_after)
  end

end


describe ToDoZapToTop do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'moves the task at the cursor to position 0' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2\n",
      "L: task 3\n",
      "L: task 4\n"
    ]

    output = [
      [0, " ", "L: task 2\n"],
      [1, " ", "L: task 0\n"],
      [2, "-", "L: task 1\n"],
      [3, " ", "L: task 3\n"],
      [4, " ", "L: task 4\n"]
    ]

    f_io.tasks_content = tasks.join
    session.list.cursor_set(2)
    ToDoZapToTop.new.run("zz", session)

    expect(o).to eq(output)
  end

  it 'does nothing when the cursor is already at position 0' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2\n",
      "L: task 3\n",
      "L: task 4\n"
    ]
    
    output = [
      [0, "-", "L: task 0\n"],
      [1, " ", "L: task 1\n"],
      [2, " ", "L: task 2\n"],
      [3, " ", "L: task 3\n"],
      [4, " ", "L: task 4\n"]
    ]

    f_io.tasks_content = tasks.join
    session.list.cursor_set(0)
    ToDoZapToTop.new.run("zz", session)

    expect(o).to eq(output)
  end

end

describe ToDoSaveActions do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'saves the tasks without quitting' do
    tasks_content = "L: task 1\nL: task 2\n"
    f_io.tasks_content = tasks_content

    ToDoSaveActions.new.run("@", session)

    expect(f_io.tasks_content).to eq(tasks_content)
  end
end

# File: ./spec/testrenderer.rb

class TestRenderer 

  attr_reader :rendered_data

  def render list
    @rendered_data = list.window
  end

end

def rendering_of session
  target = TestRenderer.new
  session.render(target)

  target.rendered_data
end
# File: ./spec/commands/help_spec.rb
require 'spec_helper'
require 'session'
require 'commands/help'
require 'fakeappio'


class TestingHelp < Help
  attr_accessor :descs

  def command_descs
    @descs
  end
end

describe Help do
  let(:io) { FakeAppIo.new }
  let(:session) { Session.from_ios(io, io) }
  let(:help_command) { TestingHelp.new }

  it 'displays help information for each command' do
    commands = [
      ["cmd1", "description 1"],
      ["cmd2", "description 2"],
      ["cmd3", "description 3"]
    ]

    help_command = TestingHelp.new
    help_command.descs = commands
    help_command.run("h", session)

    expect(io.console_output_content).to include("cmd1     - description 1")
    expect(io.console_output_content).to include("cmd2     - description 2")
    expect(io.console_output_content).to include("cmd3     - description 3")
  end

  it 'aligns command names and descriptions properly' do
    commands = [
      ["short", "a short command"],
      ["a_very_long_command", "a long command"],
      ["medium_length", "a medium length command"]
    ]

    sorted_commands = commands.sort_by { |cmd| cmd[0] }

    max_length = 19
    format = "%-#{max_length + 5}s- %s"

    expected_output = "\n" + sorted_commands.map { |cmd| format % cmd }.join("\n") + "\n\n"

    help_command = TestingHelp.new
    help_command.descs = sorted_commands
    help_command.run("h", session)

    expect(io.console_output_content).to eq(expected_output)
  end

  it 'returns to the prompt after displaying help' do
    commands = [
      ["cmd1", "description 1"],
      ["cmd2", "description 2"]
    ]

    expect(io).to receive(:get_from_console)

    help_command = TestingHelp.new
    help_command.descs = commands
    help_command.run("h", session)
  end

  it 'lists all the commands' do
    NON_CMD_LINE_COUNT = 2
    CURRENT_CMD_COUNT = 40

    commands = ObjectSpace.each_object(Class)
                          .select { |klass| klass < Command }
                          .sort_by { |klass| klass.name }
                          .map {|k| k.new.description }

    help = TestingHelp.new
    help.descs = commands
    help.run("h", session)

    # iterate for coverage
    help.command_descs.map {|x| x.name + " " + x.line }

    expect(io.console_output_content.lines.count - NON_CMD_LINE_COUNT).to eq(CURRENT_CMD_COUNT)
  end
end

# File: ./spec/commands/display_edit_spec.rb
require 'spec_helper'
require 'session'
require 'commands/display_edit'
require 'fakeappio'


describe DisplayEdit do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }

  it 'displays the line at the cursor with numbered columns' do
    f_io.tasks_content = "L: This is a test line\n"
    session.list.cursor_set(0)

    DisplayEdit.new.run("ed", session)

    expected_output = "L: This is a test line\n" +
                      "   1    2  3 4    5    \n\n"
    expect(f_io.console_output_content).to eq(expected_output)
  end

  it 'returns to the prompt after displaying the numbered line' do
    f_io.tasks_content = "W: Yet another test\n"
    session.list.cursor_set(0)

    expect(f_io).to receive(:get_from_console)

    DisplayEdit.new.run("ed", session)
  end

  it 'displays an empty line if the cursor is on an empty line' do
    f_io.tasks_content = "\n"
    session.list.cursor_set(0)

    DisplayEdit.new.run("ed", session)

    expect(f_io.console_output_content).to eq("")
  end

  describe '#matches?' do
    it 'matches a command with "ed"' do
      expect(DisplayEdit.new.matches?('ed')).to be_truthy
    end

    it 'does not match a command other than "ed"' do
      expect(DisplayEdit.new.matches?('zz')).to be_falsey
    end
  end
end

# File: ./spec/commands/move_task_to_other_spec.rb
require 'spec_helper'
require 'commands/move_task_to_other'
require 'session'
require 'fakeappio'


describe MoveTaskToOther do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }

  describe '#run' do
    it 'moves the task at the cursor from the foreground list to the background list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      session.list.cursor_set(1)

      MoveTaskToOther.new.run('-', session)
      session.save

      expect(f_io.tasks_content).to eq("Task 1\nTask 3\n")
      expect(b_io.tasks_content).to eq("Task 2\n")
    end

    it 'moves the task at the cursor from the background list to the foreground list' do
      b_io.tasks_content = "Task A\nTask B\nTask C\n"
      session.switch_lists
      session.list.cursor_set(1)

      MoveTaskToOther.new.run('-', session)
      session.save

      expect(f_io.tasks_content).to eq("Task B\n")
      expect(b_io.tasks_content).to eq("Task A\nTask C\n")
    end

    it 'does not modify the lists if the foreground list is empty' do
      f_io.tasks_content = ""
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      MoveTaskToOther.new.run('-', session)
      session.save

      expect(f_io.tasks_content).to eq("")
      expect(b_io.tasks_content).to eq("\nTask A\nTask B\nTask C\n")
    end

    it 'does not modify the lists if the background list is empty' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = ""
      session.switch_lists

      MoveTaskToOther.new.run('-', session)
      session.save

      expect(f_io.tasks_content).to eq("\nTask 1\nTask 2\nTask 3\n")
      expect(b_io.tasks_content).to eq("")
    end
  end

  describe '#matches?' do
    it 'matches a command with "-"' do
      expect(MoveTaskToOther.new.matches?('-')).to be_truthy
    end

    it 'does not match a command other than "-"' do
      expect(MoveTaskToOther.new.matches?('x')).to be_falsey
    end
  end
end

# File: ./spec/commands/edit_insert_spec.rb
require 'spec_helper'
require 'session'
require 'commands/edit_insert'
require 'fakeappio'
require 'testrenderer'

describe EditInsert do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of (session)}

  describe '#run' do
    it 'inserts tokens before the specified position in the current task' do
      f_io.tasks_content = "L: task one two three\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 2 new inserted", session)

      expect(o).to eq([[0, "-", "L: task new inserted one two three\n"]])
    end

    it 'handles insertion at the beginning of the task' do
      f_io.tasks_content = "R: existing task\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 1 prefix", session)

      expect(o).to eq([[0, "-", "R: prefix existing task\n"]])
    end

    it 'handles insertion at the end of the task' do
      f_io.tasks_content = "W: end insertion\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 3 appended text", session)

      expect(o).to eq([[0, "-", "W: end insertion appended text\n"]])
    end

    it 'does not modify the task if the position is out of bounds' do
      f_io.tasks_content = "L: unchanged task\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 10 out of bounds", session)

      expect(o).to eq([[0,"-","L: unchanged task\n"]])
    end

    it 'handles insertion with multiple tokens' do
      f_io.tasks_content = "R: before after\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 2 multiple new tokens here", session)

      expect(o).to eq([[0, "-", "R: before multiple new tokens here after\n"]])
    end

    it 'does nothing when no tokens are provided' do
      f_io.tasks_content = "W: no change\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 2", session)

      expect(o).to eq([[0, "-", "W: no change\n"]])
    end

    it 'preserves the task tag when inserting' do
      f_io.tasks_content = "L: preserve tag\n"
      session.list.cursor_set(0)

      EditInsert.new.run("ei 1 inserted", session)

      expect(o).to eq([[0, "-", "L: inserted preserve tag\n"]])
    end
  end

  describe '#matches?' do
    it 'matches a command with "ei" followed by a number and text' do
      expect(EditInsert.new.matches?('ei 2 inserted text')).to be_truthy
    end

    it 'does not match a command without "ei"' do
      expect(EditInsert.new.matches?('e 2 text')).to be_falsey
    end

    it 'does not match a command with "ei" but no position' do
      expect(EditInsert.new.matches?('ei text')).to be_falsey
    end

    it 'does not match a command with "ei" and position but no text' do
      expect(EditInsert.new.matches?('ei 2')).to be_falsey
    end
  end

  describe '#description' do
    it 'returns the correct command description' do
      expect(EditInsert.new.description.name).to eq('ei position text')
      expect(EditInsert.new.description.line).to eq('insert text before the specified position in the current task')
    end
  end
end

# File: ./spec/commands/find_spec.rb
require 'spec_helper'
require 'commands/find'
require 'session'
require 'fakeappio'

describe Find do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:command) { Find.new }

  describe '#matches?' do
    it 'returns true for "f" followed by text' do
      expect(command.matches?('f search_text')).to be true
    end

    it 'returns true for "f" followed by text and a number' do
      expect(command.matches?('f search_text 5')).to be true
    end

    it 'returns false for "f" alone' do
      expect(command.matches?('f')).to be false
    end

    it 'returns false for other commands' do
      expect(command.matches?('other_command')).to be false
    end
  end

  describe '#run' do
    before do
      f_io.tasks_content = "Task 1\nTask 2\nAnother task\nYet another task\n"
    end

    it 'finds tasks containing the specified text' do
      command.run('f task', session)
      expect(f_io.console_output_content).to include('Task 1')
      expect(f_io.console_output_content).to include('Task 2')
      expect(f_io.console_output_content).to include('Another task')
      expect(f_io.console_output_content).to include('Yet another task')
    end

    it 'limits results when a number is specified' do
      command.run('f task 2', session)
      expect(f_io.console_output_content.scan(/task/i).count).to eq(2)
    end

    it 'is case-insensitive' do
      command.run('f TASK', session)
      expect(f_io.console_output_content).to include('Task 1')
      expect(f_io.console_output_content).to include('Task 2')
    end

    it 'returns to prompt after displaying results' do
      expect(f_io).to receive(:get_from_console)
      command.run('f task', session)
    end

    it 'clears the console before displaying results' do
      expect(f_io).to receive(:clear_console)
      command.run('f task', session)
    end

    it 'displays the count of found tasks' do
      command.run('f task', session)
      expect(f_io.console_output_content).to include('4')
    end

    it 'handles no matches' do
      command.run('f nonexistent', session)
      expect(f_io.console_output_content).to include('0')
    end
  end
end

# File: ./spec/commands/edit_replace_spec.rb
require 'spec_helper'
require 'session'
require 'commands/edit_replace'
require 'fakeappio'


describe EditReplace do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'replaces when text to replacement is present' do
    f_io.tasks_content = "L: task AA\nL: task BB\n"
    session.list.cursor_set(1)

    EditReplace.new.run("er 2 bb", session)

    expect(o).to eq([[0," ","L: task AA\n"], [1,"-","L: task bb\n"]])
  end

  it 'replaces multiple tokens' do
    f_io.tasks_content = "L: old task here\n"
    session.list.cursor_set(0)

    EditReplace.new.run("er 2 new task there", session)

    expect(o).to eq([[0,"-","L: old new task there\n"]])
  end

  it 'replaces tokens until replacements run out' do
    f_io.tasks_content = "L: old old old task\n"
    session.list.cursor_set(0)

    EditReplace.new.run("er 2 new new", session)

    expect(o).to eq([[0,"-","L: old new new task\n"]])
  end

  it 'replaces tokens past the end of the original line' do
    f_io.tasks_content = "L: old old old\n"
    session.list.cursor_set(0)

    EditReplace.new.run("er 2 new new new", session)

    expect(o).to eq([[0,"-","L: old new new new\n"]])
  end

  it 'deletes token at position when no replacement provided' do
    f_io.tasks_content = "L: this is a task\n"
    session.list.cursor_set(0)

    EditReplace.new.run("er 2", session)

    expect(o).to eq([[0,"-","L: this a task\n"]])
  end
end

# File: ./spec/commands/global_find_spec.rb
require 'spec_helper'
require 'commands/global_find'
require 'session'
require 'fakeappio'

describe GlobalFind do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }

  describe '#run' do
    it 'finds tasks containing the specified text in the foreground list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      GlobalFind.new.run('gf 2', session)

      expect(f_io.console_output_content).to include("Task 2")
    end

    it 'finds tasks containing the specified text in the background list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      GlobalFind.new.run('gf B', session)

      expect(f_io.console_output_content).to include("Background:")
      expect(f_io.console_output_content).to include("Task B")
    end

    it 'finds tasks containing the specified text in both lists' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task 2\nTask B\nTask C\n"

      GlobalFind.new.run('gf 2', session)

      expect(f_io.console_output_content).to include("Task 2")
      expect(f_io.console_output_content).to include("Background:")
      expect(f_io.console_output_content).to include("Task 2")
    end

    it 'does not find tasks if the specified text is not present in either list' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      GlobalFind.new.run('gf X', session)

      expect(f_io.console_output_content).not_to include("Task")
    end

    it 'returns to the prompt after displaying the search results' do
      f_io.tasks_content = "Task 1\nTask 2\nTask 3\n"
      b_io.tasks_content = "Task A\nTask B\nTask C\n"

      expect(f_io).to receive(:get_from_console)

      GlobalFind.new.run('gf 2', session)
    end
  end

  describe '#matches?' do
    it 'matches a command with "gf" followed by text' do
      expect(GlobalFind.new.matches?('gf text')).to be_truthy
    end

    it 'does not match a command without "gf"' do
      expect(GlobalFind.new.matches?('text')).to be_falsey
    end

    it 'does not match a command with "gf" but no text' do
      expect(GlobalFind.new.matches?('gf')).to be_falsey
    end
  end
end

# File: ./spec/commands/edit_spec.rb
require 'spec_helper'
require 'session'
require 'commands/edit'
require 'fakeappio'
require 'testrenderer'


describe Edit do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  describe '#run' do
    it 'edits the task at the cursor' do
      f_io.tasks_content = "L: old task\nR: another task\n"
      session.list.cursor_set(0)

      Edit.new.run("e new task", session)

      expect(o).to eq([[0, "-", "L: new task\n"], [1, " ", "R: another task\n"]])
    end

    it 'preserves the tag when editing' do
      f_io.tasks_content = "W: old work task\nR: another task\n"
      session.list.cursor_set(0)

      Edit.new.run("e updated work task", session)

      expect(o).to eq([[0, "-", "W: updated work task\n"],[1, " ", "R: another task\n"]])
    end

    it 'does nothing when the task list is empty' do
      f_io.tasks_content = ""

      Edit.new.run("e new task", session)

      expect(o).to eq([])
    end

    it 'does nothing when editing an empty line' do
      f_io.tasks_content = "\n"
      session.list.cursor_set(0)

      Edit.new.run("e new task", session)

      expect(o).to eq([[0, "-", "\n"]]) 
    end

    it 'handles multiple words in the edit command' do
      f_io.tasks_content = "L: old single word\n"
      session.list.cursor_set(0)

      Edit.new.run("e new multiple word task", session)

      expect(o).to eq([[0, "-", "L: new multiple word task\n"]])
    end
  end

  describe '#matches?' do
    it 'matches a command starting with "e" followed by text' do
      expect(Edit.new.matches?('e new task')).to be_truthy
    end

    it 'does not match a command without "e"' do
      expect(Edit.new.matches?('new task')).to be_falsey
    end

    it 'does not match a command with only "e"' do
      expect(Edit.new.matches?('e')).to be_falsey
    end

    it 'matches a command with "e" and multiple words' do
      expect(Edit.new.matches?('e new multiple word task')).to be_truthy
    end
  end
end

# File: ./spec/commands/down_spec.rb
require 'spec_helper'
require 'session'
require 'commands/down'
require 'fakeappio'


describe Down do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'pages when cursor set off page' do
    page_size = TaskList::PAGE_SIZE
    pos       = page_size - 1

    tasks     =  50.times.map {|n| "L: task #{n}\n" }
    expected  =  50.times.map {|n| [n,(n == (pos + 1) ? "-" : " "), "L: task #{n}\n"] }

    f_io.tasks_content = tasks.join

    CursorSet.new.run("c #{pos}", session)
    Down.new.run("d", session)

    expect(o).to eq(expected.drop(page_size).take(page_size))
  end
end

# File: ./spec/commands/insert_blank_spec.rb
require 'spec_helper'
require 'commands/insert_blank'
require 'session'
require 'fakeappio'
require 'testrenderer'


describe InsertBlank do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'inserts a blank line at the current cursor position' do
    f_io.tasks_content = "L: task AA\nL: task BB\n"
    session.list.cursor_set(0)

    InsertBlank.new.run("i", session)

    expect(o).to eq([[0,"-", "\n"],[1," ","L: task AA\n"],[2," ", "L: task BB\n"]])
  end

  it 'inserts a blank line and maintains the cursor position on the same task' do
    f_io.tasks_content = "L: task AA\nL: task BB\n"
    session.list.cursor_set(0)

    InsertBlank.new.run("i", session)
    session.list.down

    expect(session.list.task_at_cursor).to eq("L: task AA") # Cursor should now
  end
end

# File: ./spec/commands/save_to_yesterday_spec.rb
require 'spec_helper'
require 'session'
require 'fakeappio'
require 'spec_helper'
require 'commands/save_to_yesterday'
require 'fakeappio'

describe SaveToYesterday do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:command) { SaveToYesterday.new }

  describe '#matches?' do
    it 'returns true for "sy"' do
      expect(command.matches?('sy')).to be true
    end

    it 'returns false for other commands' do
      expect(command.matches?('s')).to be false
      expect(command.matches?('save')).to be false
    end
  end

  describe '#process' do
    before do
      allow(f_io).to receive(:today).and_return(Day.from_text('2023-06-15'))
      f_io.tasks_content = "L: task 1\nR: task 2\nW: task 3\n"
      session.list.cursor_set(1)
    end

    it 'saves the current task to the archive with yesterday\'s date' do
      command.process('sy', session)
      expect(f_io.archive_content).to eq("2023-06-14 R: task 2\n")
    end

    it 'inserts in the right position' do
      f_io.tasks_content = "R: task prior\n"
      f_io.archive_content = "2023-06-15 R: task existing\n"
      session = Session.from_ios(f_io, f_io)
      command.process('sy', session)
      expect(f_io.archive_content).to eq("2023-06-14 R: task prior\n2023-06-15 R: task existing\n")
    end

    it 'removes the saved task from the task list' do
      command.process('sy', session)
      session.save
      expect(f_io.tasks_content).to eq("L: task 1\nW: task 3\n")
    end

    it 'does nothing if the task list is empty' do
      f_io.tasks_content = ""
      f_io.archive_content = ""
      session = Session.from_ios(f_io, f_io)
      command.process('sy', session)
      expect(f_io.archive_content).to be_empty
    end

    it 'does nothing if the cursor is on an empty line' do
      f_io.tasks_content = "L: task 1\n\nW: task 3\n"
      session = Session.from_ios(f_io, f_io)
      session.list.cursor_set(1)
      command.process('sy', session)
      expect(f_io.archive_content).to be_empty
      expect(f_io.tasks_content).to eq("L: task 1\n\nW: task 3\n")
    end
  end

  describe '#description' do
    it 'returns the correct command description' do
      expect(command.description.name).to eq('sy')
      expect(command.description.line).to eq('save task at cursor to archive with yesterday\'s date')
    end
  end
end

# File: ./spec/commands/iterative_find_spec.rb
require 'spec_helper'
require 'commands/iterative_find'
require 'session'
require 'fakeappio'
require 'testrenderer'


describe IterativeFind do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of (session) }

  it 'finds the token and moves the cursor to the line where it is first found' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2 with token\n",
      "L: task 3 with token\n",
      "L: task 4\n"
    ]
    expected = tasks.map.with_index do |task, i|
      cursor = i == 2 ? '-' : ' '
      [i, cursor, task]
    end

    f_io.tasks_content = tasks.join
    session.on_list {|list| list.cursor_set(1) }
    IterativeFind.new.run("ff token", session)

    expect(o).to eq(expected)
  end

  it 'does not change the cursor position if the token is not found' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2\n",
      "L: task 3\n",
      "L: task 4\n"
    ]

    expected = tasks.map.with_index do |task, i|
      cursor = i == 1 ? '-' : ' '
      [i, cursor, task]
    end

    f_io.tasks_content = tasks.join

    session.on_list {|list| list.cursor_set(1) }
    IterativeFind.new.run("ff token", session)

    expect(o).to eq(expected)
  end

  it 'finds the token from the next line after the cursor when no text is provided' do
    tasks = [
      "L: task 0\n",
      "L: task 1 with token\n",
      "L: task 2\n",
      "L: task 3 with token\n",
      "L: task 4\n"
    ]
  
    expected = tasks.map.with_index do |task, i|
      cursor = i == 3 ? '-' : ' '
      [i, cursor, task]
    end

    f_io.tasks_content = tasks.join

    session.on_list {|list| list.cursor_set(1) }
    IterativeFind.new.run("ff token", session)
    IterativeFind.new.run("ff", session)

    expect(o).to eq(expected)
  end
end

# File: ./spec/commands/cursor_set_spec.rb
require 'spec_helper'
require 'session'
require 'commands/cursor_set'
require 'fakeappio'
require 'testrenderer'

def rendering_of session
  target = TestRenderer.new
  session.render(target)

  target.rendered_data
end

describe CursorSet do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }


  it 'pages when cursor set off page' do
    page_size          = TaskList::PAGE_SIZE
    pos                = page_size + 5

    tasks              =  50.times.map {|n| "L: task #{n}\n" }
    expected           =  50.times.map {|n| [n,n == pos ? "-" : " " , "L: task #{n}\n"] }
    f_io.tasks_content =  tasks.join
    
    CursorSet.new.run("c #{pos}", session)

    expect(o).to eq(expected.drop(page_size).take(page_size))
  end
end

# File: ./spec/commands/add_spec.rb
require 'spec_helper'
require 'session'
require 'commands/add'
require 'fakeappio'


describe Add do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }

  describe '#run' do
    it 'adds a new task to the beginning of the list' do
      Add.new.run('a New task', session)
      expect(session.list.task_at_cursor).to eq('New task')
    end

    it 'sets the cursor to the newly added task' do
      Add.new.run('a New task', session)
      Add.new.run('a Another task', session)
      expect(session.list.task_at_cursor).to eq('Another task')
    end

    it 'trims leading and trailing whitespace from the task text' do
      Add.new.run('a   Task with whitespace   ', session)
      expect(session.list.task_at_cursor).to eq('Task with whitespace')
    end

    it 'does not add an empty task' do
      Add.new.run('a', session)
      expect(session.list.task_at_cursor).to eq('')
    end

    it 'adds multiple tasks in the correct order' do
      Add.new.run('a Task 1', session)
      Add.new.run('a Task 2', session)
      Add.new.run('a Task 3', session)

      expect(session.list.task_at_cursor).to eq('Task 3')
      session.list.down
      expect(session.list.task_at_cursor).to eq('Task 2')
      session.list.down
      expect(session.list.task_at_cursor).to eq('Task 1')
    end
  end

  describe '#matches?' do
    it 'matches a command starting with "a"' do
      expect(Add.new.matches?('a New task')).to be_truthy
    end

    it 'does not match a command not starting with "a"' do
      expect(Add.new.matches?('x New task')).to be_falsey
    end
  end
end

# File: ./spec/commands/cursor_to_start_spec.rb
require 'spec_helper'
require 'session'
require 'commands/cursor_to_start'
require 'fakeappio'


describe CursorToStart do
  let(:f_io) { FakeAppIo.new }
  let(:b_io) { FakeAppIo.new }
  let(:session) { Session.from_ios(f_io, b_io) }
  let(:o) { rendering_of(session) }

  it 'moves the cursor to the 0th task when not already there' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2\n"
    ]
    expected = tasks.map.with_index do |task, i|
      [i, i.zero? ? '-' : ' ', task]
    end

    f_io.tasks_content = tasks.join
    session.list.cursor_set(2)
    CursorToStart.new.run("cc", session)

    expect(o).to eq(expected)
  end

  it 'does nothing when cursor is already at 0th task' do
    tasks = [
      "L: task 0\n",
      "L: task 1\n",
      "L: task 2\n"
    ]
    expected = tasks.map.with_index do |task, i|
      [i, i.zero? ? '-' : ' ', task]
    end

    f_io.tasks_content = tasks.join
    CursorToStart.new.run("cc", session)

    expect(o).to eq(expected)
  end
  
end

# File: ./spec/commands/up_spec.rb
require 'spec_helper'
require_relative '../../lib/commands/up'
require_relative '../../lib/session'
require_relative '../../spec/fakeappio'

RSpec.describe Up do
  let(:command) { Up.new }
  let(:session) { Session.from_ios(FakeAppIo.new, FakeAppIo.new) }

  describe '#description' do
    it 'returns the correct command description' do
      expect(command.description).to eq(CommandDesc.new("u", "move cursor up"))
    end
  end

  describe '#matches?' do
    it 'returns true for "u"' do
      expect(command.matches?("u")).to be true
    end

    it 'returns false for other inputs' do
      expect(command.matches?("up")).to be false
      expect(command.matches?("down")).to be false
    end
  end

  describe '#process' do
    it 'calls up on the list in the session' do
      list = double('list')
      allow(session).to receive(:on_list).and_yield(list)
      expect(list).to receive(:up)

      command.process("u", session)
    end
  end
end

# File: ./spec/day_spec.rb
require 'spec_helper'
require 'day'
require 'fakeappio'


describe Day do
  it 'constructs a day from a string' do
    day = Day.from_text("2022-12-21")
    expect(day.day).to    eq("21")
    expect(day.month).to  eq("Dec")
    expect(day.year).to   eq("2022")

    expect(day.month_no).to eq(12)
  end

  it 'creates a text reprsentation of itself' do
    day = Day.from_text("2022-12-21")
    expect(day.to_s).to eq("2022-12-21")
  end

  it 'creates the next day'  do
    day = Day.from_text("2022-12-21").with_more_days(1)
    expect(day.to_s).to eq("2022-12-22")
  end

end

# File: ./lib/commands.rb
require 'gruff'
require_relative 'command'
require_relative 'session'
require_relative 'appio'


class ToDoTrendChart < Command
  def matches? line
    (line.split in ["tc", *args]) && args.count <= 1
  end

  def process line, session
    opt_year = line.split[1] if line.split.count == 2
    session.on_list {|list| list.todo_trend_chart(opt_year) }
  end

  def description
    CommandDesc.new("tc", "show trend chart")
  end
end

class ToDoSaveActions < Command
  def matches?(line)
    line.split == ["@"]
  end

  def process(line, session)
    session.save
  end

  def description
    CommandDesc.new("@", "save the tasks without quitting")
  end
end

class ToDoPush < Command
  def matches? line
    (line.split in ["p", *args]) && args.count == 1
  end

  def process line, session
    session.on_list {|list| list.todo_push(line.split[1]) }
  end

  def description
    CommandDesc.new("p  n", "push task at cursor forward n number of days")
  end
end

class ToDoRemove < Command
  def matches? line
    line.split == ["r"]
  end

  def process line, session
    session.on_list {|list| list.todo_remove }
  end

  def description
    CommandDesc.new("r", "remove task at cursor")
  end
end

class ToDoSave < Command
  def matches? line
    line.split == ["s"]
  end

  def process line, session
    session.on_list {|list| list.todo_save }
  end

  def description
    CommandDesc.new("s", "save task at cursor")
  end
end

class ToDoSaveNoRemove < Command
  def matches? line
    line.split == ["ss"]
  end

  def process line, session
    session.on_list {|list| list.todo_save_no_remove }
  end

  def description
    CommandDesc.new("ss", "save task at cursor without removing")
  end
end

class ToDoShowUpdates < Command
  def matches? line
    line.split == ["pp"]
  end

  def process line, session
    session.on_list {|list| list.todo_show_updates }
  end

  def description
    CommandDesc.new("pp", "show updates")
  end
end

class ToDoIterativeFind < Command
  def matches?(line)
    (line.split in ["ff", *args]) && args.count <= 1
  end

  def process line, session
    text = line.split[1]
    session.on_list do |list|
      text ? list.todo_iterative_find_init(text) : list.todo_iterative_find_continue
    end
  end

  def description
    CommandDesc.new("ff [text]", "find the first occurrence of text starting from the cursor position (or from the top if text is provided")
  end
end

class ToDoToday < Command
  def matches? line
    (line.split in ["t", *args]) && args.count <= 1
  end

  def process line, session
    session.on_list {|list| list.todo_today(line.split.count == 1 ? 0 : line.split[1]) }
  end

  def description
    CommandDesc.new("t  [n]", "show tasks n days prev. If no arg, defaults to today")
  end
end

class ToDoTrend < Command
  def matches? line
    line.split == ["tr"]
  end

  def process line, session
    session.on_list {|list| list.todo_trend }
  end

  def description
    CommandDesc.new("tr", "show trend")
  end
end

class ToDoGrabToggle < Command
  def matches? line
    line.split == ["g"]
  end

  def process line, session
    session.on_list {|list| list.todo_grab_toggle }
  end

  def description
    CommandDesc.new("g", "toggle grab mode")
  end
end

class ToDoMoveToRandomPositionOnOtherList < Command
  def matches?(line)
    line.split == ["_"]
  end

  def process(line, session)
    return if session.list.empty?
    session.move_task_to_random_position_on_other_list
  end

  def description
    CommandDesc.new("_", "move the task at the cursor to a random position on the other list")
  end
end

class ToDoPageDown < Command
  def matches? line
    line.split == ["dd"]
  end

  def process line, session
    session.on_list {|list| list.todo_page_down }
  end

  def description
    CommandDesc.new("dd", "page down")
  end
end

class ToDoPageUp < Command
  def matches? line
    line.split == ["uu"]
  end

  def process line, session
    session.on_list {|list| list.todo_page_up }
  end

  def description
    CommandDesc.new("uu", "page up")
  end
end

class ToDoPrintArchive < Command
  def matches?(line)
    line.split == ["pa"]
  end

  def process line, session
    session.on_list {|list| list.todo_print_archive }
  end

  def description
    CommandDesc.new("pa", "print the archive")
  end
end

class ToDoZapToPosition < Command
  def matches? line
    (line.split in ["z", *args]) && args.count == 1
  end

  def process line, session
    session.on_list {|list| list.todo_zap_to_position(line.split[1].to_i) }
  end

  def description
    CommandDesc.new("z  n", "move (zap) task at cursor to line n")
  end
end

class ToDoTodayTargetFor < Command
  def matches? line
    (line.split in ["tf", *args]) && args.count == 1
  end

  def process line, session
    session.on_list {|list| list.todo_target_for(line.split[1].to_i) }
  end

  def description
    CommandDesc.new("tf n", "show how many more tasks are needed today to stay on track for n this month")
  end
end

class ToDoSurface < Command
  def matches? line
    (line.split in ["su", *args]) && args.count <= 1
  end

  def process line, session
    count_items = line.split.count > 1 ? line.split[1].to_i : 1
    session.surface(count_items)
  end

  def description
    CommandDesc.new("su", "surface the last task by putting it first")
  end
end

class ToDoReTag < Command
  def matches? line
    (line.split in ["rt", *args]) && args.count == 1
  end

  def process line, session
    session.on_list {|list| list.todo_retag(line.split[1]) }
  end

  def description
    CommandDesc.new("tr tag", "re-tag the task at the cursor with tag. Tag if not tagged")
  end
end

class ToDoTagTallies < Command
  def matches? line
    line.split == ["tt"]
  end

  def process line, session
    session.on_list {|list| list.todo_tag_tallies }
  end

  def description
    CommandDesc.new("tt", "show tally of all tag types")
  end
end

class ToDoSwitchLists < Command
  def matches? line
    (line.split in ["w", *args]) && (args.count == 0 || (args.count == 1 && args[0] =~ /^\d+$/))
  end

  def process line, session
    target_position = nil
    tokens = line.split

    target_position = tokens[1].to_i if tokens.count == 2

    session.switch_lists(target_position)
  end

  def description
    CommandDesc.new("w [n]", "switch foreground and background lists, optionally moving cursor to position n")
  end
end

class ToDoShowCommandFrequencices  < Command
  def matches? line
    line.split == ["sf"]
  end

  def process line, session
    session.on_list {|list| list.todo_show_command_frequencies }
  end

  def description
    CommandDesc.new("sf ", "show command frequencies")
  end
end

class ToDoZapToTop < Command
  def matches?(line)
    line.split == ["zz"]
  end

  def process(line, session)
    session.on_list {|list| list.todo_zap_to_top }
  end

  def description
    CommandDesc.new("zz", "move the task at the cursor to the top (position 0)")
  end
end

# File: ./lib/nullrenderer.rb

class NullRenderer  

  def render list 
  end
  
end
# File: ./lib/tasklist.rb
require_relative 'day'
require_relative 'taskselection'
require_relative 'monthsreport'
require_relative 'appio'
require_relative 'array_ext'


class TaskList

  PAGE_SIZE    = 40
  TAG_PATTERN  = /^[A-Z]:$/

  attr_reader :io, :description

  def initialize io, description = ""
    @io = io
    @tasks = io.read_tasks.lines

    @last_search_text = nil
    @cursor = 0
    @grab_mode = false
    @page_no = 0

    @description = description + $/ + $/
  end

  def empty?
    @tasks.empty?
  end

  def add task_line
    @tasks = [task_line + $/] + @tasks
    @cursor = 0
    adjust_page
  end

  def save_all
    @io.write_tasks(@tasks)
  end

  def cursor_set line_no
    @cursor = line_no.clamp(0, @tasks.count - 1)
    adjust_page
  end

  def down
    return if @tasks.count == 0
    return if @cursor >= @tasks.count - 1

    @tasks.swap_elements(@cursor, @cursor + 1) if @grab_mode
    @cursor += 1
    adjust_page
  end

  def up
    return if @tasks.count == 0
    return if @cursor <= 0

    @tasks.swap_elements(@cursor - 1, @cursor) if @grab_mode
    @cursor -= 1
    adjust_page
  end

  def edit_insert position, new_tokens
    current_task = task_at_cursor
    return if current_task.nil? || current_task.empty? || new_tokens.empty?

    task_tokens = current_task.split
    tag = task_tokens.shift if task_tokens.first =~ TAG_PATTERN

    if position.between?(1, task_tokens.size + 1)
      task_tokens.insert(position - 1, *new_tokens)
      update_task_at_cursor([tag, task_tokens.join(' ')].compact.join(' '))
    end
  end

  def todo_find text, limit = nil
    @io.clear_console

    found           = find(text)
    found_to_report = limit ? found.take(limit) : found

    report = "#{found_to_report.join}#{$/}#{found_to_report.count}#{$/}#{$/}#{$/}"
    @io.append_to_console(report)

    @io.get_from_console
  end

  def todo_print_archive
    @io.clear_console
    @io.append_to_console(@io.read_archive)
    @io.get_from_console
  end

  def todo_push days_text
    return if @tasks.count < 1

    updates = @io.read_updates.lines.to_a
    date_text = @io.today.with_more_days(days_text.to_i).to_s

    updates << [date_text, @tasks[@cursor]].join(' ')
    updates = updates.sort_by {|line| DateTime.parse(line.split.first) }

    @io.write_updates(updates)
    remove_task_at_cursor
  end

  def todo_remove
    @io.append_to_console "Remove current line (Y/N)?" + $/
    response = @io.get_from_console

    return unless response.split.first == "Y"

    line = @tasks[@cursor]
    @io.append_to_junk("#{@io.today} #{line}") unless line.strip.empty?
    remove_task_at_cursor
    @io.write_tasks(@tasks)
  end

  def todo_save
    return if @tasks.count < 1
    return if task_at_cursor.strip.empty?

    @io.append_to_archive(@io.today.to_s + " " + @tasks[@cursor])
    remove_task_at_cursor
  end

  def todo_save_all
    save_all
  end

  def todo_save_no_remove
    return if @tasks.count < 1
    return if task_at_cursor.strip.empty?

    @io.append_to_archive(@io.today.to_s + " " + @tasks[@cursor])
  end

  def todo_show_updates
    @io.clear_console
    @io.append_to_console @io.read_updates
    @io.get_from_console
  end

  def edit text
    return if @tasks.empty?
    new_tokens = text.split

    tag = task_at_cursor.split.first
    return unless tag

    update_task_at_cursor([tag, *new_tokens].join(' '))
  end

  def edit_replace position, new_tokens
    task = task_at_cursor
    return if task.nil?

    tokens = task.split
    tokens[position, new_tokens.length] = new_tokens unless new_tokens.empty?
    tokens.delete_at(position) if new_tokens.empty?

    update_task_at_cursor(tokens.join(' '))
  end

  def todo_grab_toggle
    @grab_mode = (not @grab_mode)
  end

  def todo_month_summaries year = nil
    year ||= @io.today.year_no

    MonthsReport.new(@io, year).run
  end

  def todo_today days_prev
    day_to_display = @io.today.with_fewer_days(days_prev.to_i)
    found = @io.read_archive
               .lines
               .select {|line| Day.from_text(line.split.first) === day_to_display }

    @io.append_to_console($/)
    found.each {|line| @io.append_to_console(line) }
    @io.append_to_console($/ + "#{found.count}" + $/ + $/)
    @io.get_from_console
  end

  def todo_trend
      day_frequencies.each {|e| @io.append_to_console(("%3s  %s" %  [e[1], e[0]]) + $/) }
      @io.append_to_console($/)
      @io.get_from_console
  end

  def todo_trend_chart opt_year
    g = Gruff::Line.new(1600)
    g.theme = {
      colors: %w[red],
      marker_color: 'gray',
      font_color: 'black',
      background_colors: 'white'
    }
    g.data('', day_frequencies(opt_year).map {|e| e[1] })
    g.write('trend.png')
    `open trend.png`
  end

  def todo_page_down
    return unless ((@page_no + 1) * PAGE_SIZE) < @tasks.count
    @page_no = @page_no + 1
  end

  def todo_page_up
    return unless @page_no > 0
    @page_no = @page_no - 1
  end

  def todo_zap_to_position line_no
    clamped_line_no = line_no.clamp(0, @tasks.count - 1)
    @tasks = @tasks.insert(clamped_line_no, @tasks.delete_at(@cursor))
  end

  def todo_retag new_tag
    current_task = @tasks[@cursor]
    return unless current_task

    tokens = current_task.split
    tag_text = "#{new_tag.upcase}:"

    tokens.first =~ TAG_PATTERN ? tokens[0] = tag_text : tokens.unshift(tag_text)
    @tasks[@cursor] = tokens.join(" ") + $/
  end

  def todo_target_for month_target
    today = @io.today.date
    dates = @io.read_archive
               .lines
               .map {|l| DateTime.parse(l.split[0]) }

    current_month_dates = dates.select {|date| date.month == today.month && date.year == today.year }
    tasks_done_so_far   = current_month_dates.count

    last_day_of_month = Date.new(today.year, today.month, -1)
    remaining_days    = (today..last_day_of_month).count
    remaining_tasks   = [month_target - tasks_done_so_far, 0].max
    
    tasks_per_day = remaining_days > 0 ? (remaining_tasks.to_f / remaining_days).ceil : 0

    @io.append_to_console "\n\n    Do %d per day to meet monthly goal of %d\n\n" % [tasks_per_day, month_target]
    @io.get_from_console
  end
  
  def todo_today_target_for month_target
    today = @io.today.date
    dates = @io.read_archive
               .lines
               .map {|l| DateTime.parse(l.split[0]) }

    current_month_dates = dates.select {|date| date.month == today.month && date.year == today.year }
    tasks_done_prev     = current_month_dates.count {|date| date < today }
    tasks_done_today    = current_month_dates.count(today)
    tasks_done_so_far   = tasks_done_prev + tasks_done_today

    if tasks_done_so_far >= month_target
      @io.append_to_console $/ + $/ + "    Goal met" + $/ + $/
      @io.get_from_console
      return
    end

    last_day_of_month             = Date.new(today.year, today.month, -1)
    remaining_days                = (today..last_day_of_month).count
    remaining_tasks               = month_target - tasks_done_so_far
    daily_tasks_needed            = (remaining_tasks.to_f / remaining_days).ceil

    if remaining_days == 1
      @io.append_to_console "\n\n    Do %d to meet monthly goal of %d\n\n" % [remaining_tasks, month_target]
      @io.get_from_console
      return
    end

    additional_tasks_needed_today = daily_tasks_needed - tasks_done_today
    if additional_tasks_needed_today <= 0
      @io.append_to_console "\n\n    Goal met\n\n"
    else
      @io.append_to_console "\n\n    Do %d to meet daily goal of %d\n\n" % [additional_tasks_needed_today, daily_tasks_needed]
    end

    @io.append_to_console "\n\n   Average so far:   %f" % [tasks_done_so_far.to_f / today.day]
    @io.append_to_console   "\n   Average needed:   %f" % [remaining_tasks.to_f / remaining_days]
    @io.append_to_console "\n\n"
    @io.get_from_console
  end

  def window
    @tasks.zip((0..))
          .map {|e, i| [i, cursor_char(i), e] }
          .drop(@page_no * PAGE_SIZE)
          .take(PAGE_SIZE)
  end

  def adjust_page
    @page_no = @cursor / PAGE_SIZE
  end

  def cursor_char index
    return " " unless @cursor == index
    @grab_mode ? "*" : "-"
  end

  def find text
    @tasks.each_with_index
          .map {|e, i| "%2d %s" % [i, e] }
          .grep(/#{Regexp.escape text}/i)
  end

  def remove_task_at_cursor
    @tasks.delete_at(@cursor)
    @cursor = [@cursor, @tasks.count - 1].min
  end

  def task_at_cursor
    return "" if @tasks.empty?
    @tasks[@cursor].chomp
  end

  def todo_tag_tallies
    mask = "   %-10s%3d"
    tagged = tag_tallies.map {|t, n| mask % [t, n] }.join($/)
    untagged = mask % ["Untagged", untagged_tally]

    @io.append_to_console $/ + $/ + "#{tagged}\n\n#{untagged}" + $/ + $/
    @io.get_from_console
  end

  def tag_tallies
    filter_tasks(:select).freq
  end

  def untagged_tally
    filter_tasks(:reject).count
  end

  def todo_show_command_frequencies
    data    = @io.read_log
                 .split
                 .map{|line| line.split(',') }
                 .map{|name,count| [name, count.to_i] }

    total   = data.sum {|_,count| count }

    results = data.map {|name, count| "%-5.2f  %-4d   %s" % [count * 100.0 / total, count, name]}
                  .join($/)

    @io.append_to_console $/ + results + $/ + $/
    @io.get_from_console
  end

  def todo_insert_blank
    @tasks.insert(@cursor, $/)
    adjust_page
  end

  def todo_iterative_find_init text
    @last_search_text = text
    found_position = @tasks.index { |task| task =~ /#{Regexp.escape(text)}/i }
    cursor_set(found_position) if found_position
  end

  def todo_iterative_find_continue
    text = @last_search_text
    return unless text

    start_index = [@cursor + 1, @tasks.count - 1].min
    found_position = @tasks[start_index..-1].index { |task| task =~ /#{Regexp.escape(text)}/i }
    found_position += start_index if found_position

    cursor_set(found_position) if found_position
  end

  def todo_zap_to_top
    todo_zap_to_position(0)
  end

  def count
    @tasks.count
  end

  private

  def day_frequencies year = nil
    @io.read_archive
       .lines
       .map {|line| line.split.first }
       .select {|d| !year || Day.from_text(d).year ==  year }
       .freq
  end

  def update_task_at_cursor task_text
    @tasks[@cursor] = task_text + $/
  end

  def filter_tasks method
    @tasks.select { |l| l.strip.length > 0 }
          .map { |l| l.split.first }
          .send(method) { |t| t =~ TAG_PATTERN }
  end

end

# File: ./lib/taskselection.rb
require_relative 'day'
require_relative 'appio'


class TaskSelection

  def initialize descs
    @descs = descs
  end

  def year year
    TaskSelection.new(@descs.select {|d| d.date.year.to_i == year })
  end

  def month month
    TaskSelection.new(@descs.select {|d| d.date.month_no.to_i == month })
  end

  def date date
    TaskSelection.new(@descs.select {|d| d.date === date })
  end

  def percent_of other_tasks
    other_total = count
    all_total   = other_tasks.count

    all_total.zero? ? 0 : (100.0 * other_total / all_total).to_i
  end

  def adjusted_count
    points_for_wins       = 5 * self.W.count
    points_for_all_others = count - self.W.count

    points_for_wins + points_for_all_others
  end

  def count
    @descs.count
  end

  def method_missing(method_name, *args, &block)
    if method_name.to_s.match?(/^[A-Z]$/) && args.empty? && !block_given?
      TaskSelection.new(@descs.select { |d| d.task_type == method_name.to_s })
    else
      super
    end
  end

  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.match?(/^[A-Z]$/) || super
  end
end

# File: ./lib/backgroundio.rb
require_relative "appio.rb"

BACKGROUND_FILE = ROOT_DIR + "background_todo.txt"


class BackgroundIo < AppIo

  def read_tasks
    File.read(BACKGROUND_FILE)
  end

  def write_tasks tasks
    File.open(BACKGROUND_FILE, 'w') { |f| f.write(tasks.join) }
  end

end

# File: ./lib/appio.rb
ROOT_DIR     = "/Users/michaelfeathers/Projects/todo/lib/data/"
TODO_FILE    = ROOT_DIR + "todo.txt"
UPDATE_FILE  = ROOT_DIR + "updates.txt"
ARCHIVE_FILE = ROOT_DIR + "archive.txt"
JUNK_FILE    = ROOT_DIR + "junk.txt"
LOG_FILE     = ROOT_DIR + "log.txt"
LOCK_FILE    = ROOT_DIR + "todo.lock"

class AppIo
  def read_archive
    File.read(ARCHIVE_FILE)
  end

  def write_archive archive_entries
    File.open(ARCHIVE_FILE, 'w') { |f| f.write(archive_entries.join) }
  end

  def append_to_archive line
    File.open(ARCHIVE_FILE, 'a') { |f| f.write(line); }
  end

  def append_to_log line
    File.open(LOG_FILE, 'a') { |f| f.write(line); }
  end

  def read_log
    begin
      File.read(LOG_FILE)
    rescue => e
      ""
    end
  end

  def write_log text
    File.open(LOG_FILE, 'w') { |f| f.write(text + $/); }
  end

  def append_to_junk line
    File.open(JUNK_FILE, 'a') { |f| f.write(line); }
  end

  def read_tasks
    File.read(TODO_FILE)
  end

  def write_tasks tasks
    File.open(TODO_FILE, 'w') { |f| f.write(tasks.join) }
  end

  def read_updates
    File.read(UPDATE_FILE)
  end

  def write_updates updates
    File.open(UPDATE_FILE, 'w') { |f| f.write(updates.join) }
  end

  def append_to_console text
    print text
  end

  def get_from_console
    gets
  end

  def clear_console
    puts  "\e[H\e[2J"
  end

  def today
    Day.new(DateTime.now)
  end

  def renderer
    ConsoleRenderer.new
  end

end

# File: ./lib/day.rb
require 'date'


class Day

  def self.from_text date_text
    self.new(DateTime.parse(date_text))
  end

  def self.today
    self.new(DateTime.now)
  end

  def with_more_days days
    Day.new(@date.next_day(days))
  end

  def with_fewer_days days
    Day.new(@date.prev_day(days))
  end

  def initialize date
    @date = DateTime.new(date.year, date.month, date.day, 0, 0, 0, date.zone)
  end

  def === other
    @date === other.date
  end

  def == other
    @date == other.date
  end

  def month
    @date.strftime("%b")
  end

  def month_no
    @date.month
  end

  def day
    @date.strftime("%d")
  end

  def year
    @date.strftime("%Y")
  end

  def year_no
    @date.year
  end

  def date
    @date
  end

  def to_s
    @date.to_s[0, 10]
  end
end

# File: ./lib/array_ext.rb


class Array
    def swap_elements i, j
    self[i], self[j] = self[j], self[i]
    self
  end

  def freq
    tally.sort_by(&:first)
  end

end

# File: ./lib/session.rb
require_relative 'appio'
require_relative 'tasklist'
require_relative 'consolerenderer'
require_relative 'nullrenderer'


class Session

  attr_reader :list

  def self.from_ios foreground_io, background_io
    @foreground_tasks = TaskList.new(foreground_io)
    @background_tasks = TaskList.new(background_io, "BACKGROUND")
    new(@foreground_tasks, @background_tasks)
  end

  def initialize foreground_tasks, background_tasks
    @foreground_tasks = foreground_tasks
    @background_tasks = background_tasks

    @list = @foreground_tasks
    load_command_log
  end

  def on_list
    yield @list
  end

  def switch_lists(target_position = nil)
    toggle_active_list
    @list.cursor_set(target_position) if target_position
  end

  def toggle_active_list
    @list = @list.equal?(@foreground_tasks) ? @background_tasks : @foreground_tasks
  end

  def move_task_to_other
    task = @list.task_at_cursor
    @list.remove_task_at_cursor

    switch_lists
    @list.add(task)
    switch_lists
  end

  def save
    @foreground_tasks.save_all
    @background_tasks.save_all
  end

  def add task_line
    @foreground_tasks.add task_line
  end

  def global_find(text)
    io = @list.io
    io.clear_console

    tasklists = { '' => @foreground_tasks, 'Background:' => @background_tasks }

    tasklists.each do |label, task_list|
      found = task_list.find(text)
      next if found.empty?

      io.append_to_console "#{label}#{$/}" unless label.empty?
      io.append_to_console found.join + $/ + $/
    end
    io.get_from_console

  end

  def load_command_log
    @command_log = @list.io.read_log
                         .split($/)
                         .map { |line| line.split(',') }
                         .select { |items| items.size == 2 }
                         .map { |k, v| [k, v.to_i] }
                         .to_h
    @command_log.default = 0
    @command_log
  end

  def log_command name
    text = @command_log.tap { |h| h[name] += 1 }
                       .sort_by { |_, v| -v }
                       .to_h
                       .map { |k, v| "#{k},#{v}" }
                       .join($/)

    @list.io.write_log(text)
  end

  def surface count
    count.times do
      return if @background_tasks.empty?

      @background_tasks.cursor_set(rand(@background_tasks.count))
      task = @background_tasks.task_at_cursor
      @foreground_tasks.add(task)

      @background_tasks.remove_task_at_cursor
    end

  end

  def move_task_to_random_position_on_other_list
    task = @list.task_at_cursor
    @list.remove_task_at_cursor

    other_list = (@list == @foreground_tasks) ? @background_tasks : @foreground_tasks
    random_position = rand(other_list.count)

    other_list.add(task)
    other_list.todo_zap_to_position(random_position)
  end

  def get_line
    @list.io.get_from_console.chomp
  end

  def message_and_wait text
    @list.io.append_to_console text
    @list.io.get_from_console
  end

  def render renderer = nil
    renderer ||= @list.io.renderer
    renderer.render(@list)
  end

end

# File: ./lib/headlessio.rb


class HeadlessIo < AppIo

  def initialize
    @done = false
  end

  def get_from_console
    @done ? "q\n" : (@done = true; ARGV.join(' ') + "\n")
  end

  def clear_console
  end

  def renderer
    NullRenderer.new
  end

end

# File: ./lib/trend.rb
FNAME = "/Users/michaelfeathers/Projects/todo/lib/archive.txt"


class Array
  def freq
    group_by {|e| e }.map {|k,v| [k, v.count] }.sort_by(&:first)
  end
end


puts "day, count"
File.read(FNAME)
    .lines
    .map {|line| line.split[0] }
    .freq
    .each {|e| puts "%s, %s" % [e[0], e[1]] }

# File: ./lib/consolerenderer.rb

class ConsoleRenderer  

  def render list 
    list.io.clear_console
    list.io.append_to_console list.description
  
    lines = list.window.map {|fields| format(*fields) }.join
  
    list.io.append_to_console lines + $/
  end
  
  private

  def format task_no, cursor, line
    "%2d %s%s %s%s" % [task_no, 
                       highlight_section_start(cursor), 
                       cursor, 
                       line, 
                       highlight_section_end(cursor)]
  end
  
  def highlight_section_start cursor
    cursor == ' ' ? "" : "\e[41m"
  end
  
  def highlight_section_end cursor
    cursor == ' ' ? "" : "\e[0m"
  end

end
# File: ./lib/monthsreport.rb
require_relative 'day'
require_relative 'taskdesc'
require_relative 'appio'


MONTH_NAMES = %w[Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec].freeze

def month_name_of(month_no)
  MONTH_NAMES[month_no - 1] || ''
end


class MonthsReport

  COLUMNS = [
             ["R7K",   ->(tasks) { tasks.R.count } ],
             ["Life",  ->(tasks) { tasks.L.count } ],
             ["R7K %", ->(tasks) { tasks.R.percent_of(tasks) } ],
             ["Total", ->(tasks) { tasks.count } ]
            ]


  def initialize io, year, columns = COLUMNS
    @io = io
    @year = year
    @columns = columns
    @tasks = nil

    @format = "%-5s" + @columns.size.times.map { " %10s" }.join + $/
  end

  def run
    print_header
    print_body
    print_footer

    @io.get_from_console
  end

  def print_header
    @io.append_to_console $/ + $/
    @io.append_to_console header_row

    @io.append_to_console $/
  end

  def print_body
    print_months_statistics
    print_year_statistics
    print_today_statistics
  end

  def print_footer
    @io.append_to_console $/
  end

  def print_months_statistics
    (1..12).each do |month|
      month_tasks = year_tasks.month(month)
      @io.append_to_console body_row(month_name_of(month), month_tasks)
    end

    @io.append_to_console $/
  end

  def print_today_statistics
    if today_tasks.count > 0 && @year == @io.today.year_no
      @io.append_to_console body_row("Today", today_tasks)
    end

    @io.append_to_console $/
  end

  def print_year_statistics
    @io.append_to_console body_row("", year_tasks)

    @io.append_to_console $/
  end

  def read_task_descs
    @tasks ||= @io.read_archive
                  .lines
                  .map {|l| TaskDesc.from_line(l) }
  end

  def year_tasks
    TaskSelection.new(read_task_descs).year(@year)
  end

  def today_tasks
    TaskSelection.new(read_task_descs).date(@io.today)
  end

  def body_row(label, tasks)
    @format % ([label] + @columns.map { |_, calculator| calculator.call(tasks) })
  end

  def header_row
    @format % ([""] + @columns.map(&:first))
  end

end

# File: ./lib/commands/cursor_set.rb
require_relative '../command'
require_relative '../session'


class CursorSet < Command

  def description
    CommandDesc.new("c  n", "set cursor position to line n")
  end

  def matches? line
    (line.split in ["c", *args]) && args.count == 1
  end

  def process line, session
    session.on_list do |list|
      list.cursor_set(line.split[1].to_i)
    end
  end

end

# File: ./lib/commands/iterative_find.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class IterativeFind < Command
  def matches?(line)
    (line.split in ["ff", *args]) && args.count <= 1
  end

  def process(line, session)
    session.on_list do |list|
      tokens = line.split
      if tokens.count > 1
        text = tokens[1]
        list.todo_iterative_find_init(text)
      else
        list.todo_iterative_find_continue
      end
    end
  end

  def description
    CommandDesc.new("ff [text]", "find the first occurrence of text starting from the cursor position (or from the top if text is provided")
  end
end

# File: ./lib/commands/help.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class Help < Command
  def matches? line
    line.split == ["h"]
  end

  def process line, session
    max_length = command_descs.map {|cmd| cmd[0].length }.max

    output = command_descs.sort_by(&:first)
                          .map {|name, desc| "%-#{max_length + 5}s- %s" % [name, desc] }
                          .join($/)

    session.message_and_wait $/ + "#{output}" + $/ + $/
  end

  def command_descs
    ToDo.registered_commands.map {|c| [*c.description] }
  end

  def description
    CommandDesc.new("h", "show help message")
  end
end

# File: ./lib/commands/display_edit.rb
require_relative '../command'
require_relative '../session'


class DisplayEdit < Command

  def description
    CommandDesc.new("ed", "display the task at the cursor with numbered columns")
  end

  def matches?(line)
    line.split == ["ed"]
  end

  def process line, session
    task_line = session.on_list {|list| list.task_at_cursor }
    return if task_line.split.empty?

    session.message_and_wait(message(task_line))
  end

  def message text
    tag, *words = text.split

    task_line   = words.join(' ')
    index_line  = words.map
                       .with_index {|w,i| index_field(i + 1, field_size(w))  }
                       .join

    "#{tag} #{task_line}\n   #{index_line}\n\n"
  end

  def field_size word
    word.size + 1
  end

  def index_field index, size
    index.to_s.ljust(size, ' ')
  end

end

# File: ./lib/commands/edit_replace.rb

require_relative '../command'
require_relative '../session'


class EditReplace < Command

  def description
    CommandDesc.new("er position [token...]", "replace token(s) starting at pos with replacement token(s). Delete token at pos if none.")
  end

  def matches? line
    (line.split in ["er", *args]) && args.count >= 1
  end

  def process line, session
    tokens = line.split
    position = tokens[1].to_i
    new_tokens = tokens.drop(2)

    session.on_list {|list| list.edit_replace(position, new_tokens) }
  end

end

# File: ./lib/commands/month_summaries.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class MonthSummaries < Command
  def matches? line
    (line.split in ["m", *args]) && args.count <= 1
  end

  def process line, session
    session.on_list do |list|
      month = line.split[1].to_i if line.split.size > 1
      list.todo_month_summaries(month)
    end
  end

  def description
    CommandDesc.new("m", "show month summaries")
  end
end

# File: ./lib/commands/edit_insert.rb

require_relative '../command'
require_relative '../session'


class EditInsert < Command

  def description
    CommandDesc.new("ei position text", "insert text before the specified position in the current task")
  end

  def matches?(line)
    (line.split in ["ei", *args]) && args.count >= 2 && args[0].match?(/^\d+$/)
  end

  def process(line, session)
    tokens = line.split
    position = tokens[1].to_i
    insert_tokens = tokens[2..-1]

    session.on_list {|list| list.edit_insert(position, insert_tokens) }
  end

end

# File: ./lib/commands/find.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'

class Find < Command
  def matches? line
    (line.split in ["f", *args]) && args.count >= 1
  end

  def process line, session
    limit = line.split.count == 3 ? line.split[2].to_i : nil
    session.on_list {|list| list.todo_find(line.split[1], limit) }
  end

  def description
    CommandDesc.new("f  text [n]", "find all (or [n]) tasks containing specified text")
  end
end

# File: ./lib/commands/move_task_to_other.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class MoveTaskToOther < Command
  def matches? line
    line.split == ["-"]
  end

  def process line, session
    session.move_task_to_other
  end

  def description
    CommandDesc.new("-", "move task to other list")
  end
end

# File: ./lib/commands/edit.rb

require_relative '../command'
require_relative '../session'

class Edit < Command

  def description
    CommandDesc.new("e  text", "edit task at cursor, replacing it with text")
  end

  def matches? line
    (line.split in ["e", *args]) && args.count >= 1
  end

  def process line, session
    session.on_list {|list| list.edit(line.split.drop(1).join(" ")) }
  end

end

# File: ./lib/commands/up.rb
require_relative '../command'
require_relative '../session'


class Up < Command

  def description
    CommandDesc.new("u", "move cursor up")
  end

  def matches? line
    line.split == ["u"]
  end

  def process line, session
    session.on_list {|list| list.up }
  end

end

# File: ./lib/commands/save_to_yesterday.rb
require_relative '../command'
require_relative '../day'
require_relative '../appio'

class SaveToYesterday < Command
  def matches?(line)
     line.split == ["sy"]
   end

   def process(line, session)
     session.on_list do |list|
       return if list.count == 0

       task = list.task_at_cursor
       return if task.strip.empty?

       yesterday = list.io.today.with_fewer_days(1)
       entries   = list.io.read_archive
                          .lines
                          .append("#{yesterday} #{task}\n")
                          .sort_by {|line| line.split.first }

       list.io.write_archive(entries)
       list.remove_task_at_cursor
     end
   end

   def description
     CommandDesc.new("sy", "save task at cursor to archive with yesterday's date")
   end
end

# File: ./lib/commands/insert_blank.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class InsertBlank < Command
  def matches?(line)
    line.split == ["i"]
  end

  def process(line, session)
    session.on_list {|list| list.todo_insert_blank }
  end

  def description
    CommandDesc.new("i", "insert a blank line at the cursor")
  end
end

# File: ./lib/commands/quit.rb
require_relative '../command'


class Quit < Command

  def description
    CommandDesc.new("q", "save and quit")
  end

  def matches? line
    line.split == ["q"]
  end

  def process line, session
    session.save
    exit
  end

end

# File: ./lib/commands/global_find.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class GlobalFind < Command
  def matches? line
    (line.split in ["gf", *args]) && args.count == 1
  end

  def process line, session
    session.global_find(line.split[1])
  end

  def description
    CommandDesc.new("gf text", "find text across all task lists")
  end
end

# File: ./lib/commands/down.rb
require_relative '../command'
require_relative '../session'


class Down < Command

  def description
    CommandDesc.new("d", "move cursor down")
  end

  def matches? line
    line.split == ["d"]
  end

  def process line, session
    session.on_list {|list| list.down }
  end

end

# File: ./lib/commands/add.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class Add < Command

  def description
    CommandDesc.new("a  text", "add text as a task")
  end

  def matches? line
    (line.split in ["a", *args]) && args.count >= 0
  end

  def process line, session
    session.add(line.split.drop(1).join(' '))
  end

end

# File: ./lib/commands/cursor_to_start.rb
require_relative '../command'
require_relative '../session'


class CursorToStart < Command

  def description
    CommandDesc.new("cc", "move cursor to the 0th task")
  end

  def matches?(line)
    line.split == ["cc"]
  end

  def process(line, session)
    session.on_list {|list| list.cursor_set(0) }
  end

end

# File: ./lib/commands/grab_toggle.rb
require_relative '../command'
require_relative '../session'
require_relative '../appio'


class GrabToggle < Command
  def matches? line
    line.split == ["g"]
  end

  def process line, session
    session.on_list {|list| list.todo_grab_toggle }
  end

  def description
    CommandDesc.new("g", "toggle grab mode")
  end
end

# File: ./lib/command.rb
CommandDesc = Struct.new(:name, :line)

class CommandResult
  attr_reader :matches

  def initialize
    @matches = []
  end

  def record_match command
    @matches << command
  end

  def match_count
    @matches.count
  end
end


class Command

  def run line, session, result = CommandResult.new
    return unless matches? line
    result.record_match(self)
    process line, session
  end

  def name
    description.name.split.first
  end

end

# File: ./lib/todoupdater.rb
require_relative 'appio'


class ToDoUpdater

  def initialize io
    @io = io
  end

  def run
    tasks = @io.read_tasks.lines
    updates = @io.read_updates.lines

    due_updates = due(updates)
    non_due_updates = non_due(updates)

    new_tasks = due_updates + tasks
    @io.write_tasks(new_tasks)

    sorted_non_due = non_due_updates.sort_by do |line|
      Day.from_text(line.split.first).date
    end
    @io.write_updates(sorted_non_due)
  end

  def due us
    us.select {|e| due?(e)}
      .map {|e| strip_date(e)}
  end

  def non_due us
     us.reject {|e| due?(e)}
  end

  def strip_date line
    line.split.drop(1).join(" ") + $/
  end

  def due? line
    Day.from_text(line.split.first).date <= @io.today.date
  rescue
    false
  end

end

# File: ./lib/taskdesc.rb


class TaskDesc

  attr_reader :date, :task_type

  def self.from_line line
    date_text, type_text = line.split
    TaskDesc.new(Day.from_text(date_text),
                 type_text.chars.first)
  end

  def initialize date, task_type
    @date = date
    @task_type = task_type
  end

end

